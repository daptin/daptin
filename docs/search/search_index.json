{
    "docs": [
        {
            "location": "/",
            "text": "DAPTIN\n\n\nCreate an instance\n\n\nImport data\n\n\n\n\nUpload from dashboard\n\n\nUpload one of these files:\n\n\n\n\n\n\n\n\nFile\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nSchema JSON\n\n\nCreate schema and apis\n\n\n\n\n\n\nCSV\n\n\nAuto create entity and upload data\n\n\n\n\n\n\nXLSX\n\n\nAuto create entity and upload data\n\n\n\n\n\n\nData JSON\n\n\nUpload data from dumps\n\n\n\n\n\n\n\n\nTables\n\n\nTables are the basic data structure. Tables have columns. Each column has a particular data type. These tables are exposed over APIs under the \n/api/\n path. Checkout \nentity documentation\n for details.\n\n\n\n\nYAML example\n\n\nTables\n:\n\n\n-\n \nTableName\n:\n \ntodo\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(500)\n\n    \nColumnType\n:\n \nlabel\n\n    \nIsIndexed\n:\n \ntrue\n\n\n\n\n\n\n\n\n\nJSON example\n\n\n{\n\n  \n\"Tables\"\n:\n \n[\n\n    \n{\n\n      \n\"TableName\"\n:\n \n\"todo\"\n,\n\n      \n\"Columns\"\n:\n \n[\n\n        \n{\n\n          \n\"Name\"\n:\n \n\"title\"\n,\n\n          \n\"DataType\"\n:\n \n\"varchar(500)\"\n,\n\n          \n\"ColumnType\"\n:\n \n\"label\"\n,\n\n          \n\"IsIndexed\"\n:\n \ntrue\n\n        \n}\n\n      \n]\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\n\n\nRelations\n\n\nRelations are constraints among tables and help you keep clean and consistent data. Relational data is easily accessible over APIs using a path structure like \n/api/<entityName>/<id>/<relationName>\n and the response is consistent with \nJSONAPI.org\n.\n\n\n\n\nYAML example\n\n\nRelations\n:\n\n\n-\n \nSubject\n:\n \ntodo\n\n  \nRelation\n:\n \nhas_one\n\n  \nObject\n:\n \nproject\n\n\n\n\n\n\n\n\n\nJSON example\n\n\n{\n\n  \n\"Relations\"\n:\n \n[\n\n    \n{\n\n      \n\"Subject\"\n:\n \n\"todo\"\n,\n\n      \n\"Relation\"\n:\n \n\"has_one\"\n,\n\n      \n\"Object\"\n:\n \n\"project\"\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\n\n\nActions\n\n\nActions are entity dependent APIs which you want to expose which may have an outcome of events. Most basic example is the login action which generates an oauth2 token as an outcome.\n\n\nUse action to expose endpoints for your forms and processes. Here is an example of creating a \"/action/project/new_task\" API:\n\n\n\n\nNew task action YAML\n\n\nActions\n:\n\n\n-\n \nName\n:\n \nnew_task\n\n  \nLabel\n:\n \nNew to do\n\n  \nOnType\n:\n \nproject\n\n  \nInstanceOptional\n:\n \ntrue\n\n  \nInFields\n:\n\n  \n-\n \nColumnName\n:\n \ndescription\n\n    \nName\n:\n \nDescription\n\n    \nColumnType\n:\n \nlabel\n\n  \n-\n \nColumnName\n:\n \nschedule\n\n    \nName\n:\n \nScheduled at\n\n    \nColumnType\n:\n \ndate\n\n  \nOutFields\n:\n\n  \n-\n \nType\n:\n \ntodo\n\n    \nMethod\n:\n \nPOST\n\n    \nAttributes\n:\n\n      \nschedule\n:\n \n\"~schedule\"\n\n      \ntitle\n:\n \n\"~description\"\n\n      \nproject_id\n:\n \n\"$.reference_id\"\n\n  \n-\n \nType\n:\n \nclient.notify\n\n    \nMethod\n:\n \nACTIONRESPONSE\n\n    \nAttributes\n:\n\n      \ntype\n:\n \nsuccess\n\n      \nmessage\n:\n \nCreated new todo, taking you to it.\n\n      \ntitle\n:\n \nWait for it\n\n\n\n\n\n\n\n\n\nNew task action JSON\n\n\n{\n\n  \n\"Actions\"\n:\n \n[\n\n    \n{\n\n      \n\"Name\"\n:\n \n\"new_task\"\n,\n\n      \n\"Label\"\n:\n \n\"New to do\"\n,\n\n      \n\"OnType\"\n:\n \n\"project\"\n,\n\n      \n\"InstanceOptional\"\n:\n \ntrue\n,\n\n      \n\"InFields\"\n:\n \n[\n\n        \n{\n\n          \n\"ColumnName\"\n:\n \n\"description\"\n,\n\n          \n\"Name\"\n:\n \n\"Description\"\n,\n\n          \n\"ColumnType\"\n:\n \n\"label\"\n\n        \n},\n\n        \n{\n\n          \n\"ColumnName\"\n:\n \n\"schedule\"\n,\n\n          \n\"Name\"\n:\n \n\"Scheduled at\"\n,\n\n          \n\"ColumnType\"\n:\n \n\"date\"\n\n        \n}\n\n      \n],\n\n      \n\"OutFields\"\n:\n \n[\n\n        \n{\n\n          \n\"Type\"\n:\n \n\"todo\"\n,\n\n          \n\"Method\"\n:\n \n\"POST\"\n,\n\n          \n\"Attributes\"\n:\n \n{\n\n            \n\"schedule\"\n:\n \n\"~schedule\"\n,\n\n            \n\"title\"\n:\n \n\"~description\"\n,\n\n            \n\"project_id\"\n:\n \n\"$.reference_id\"\n\n          \n}\n\n        \n},\n\n        \n{\n\n          \n\"Type\"\n:\n \n\"client.notify\"\n,\n\n          \n\"Method\"\n:\n \n\"ACTIONRESPONSE\"\n,\n\n          \n\"Attributes\"\n:\n \n{\n\n            \n\"type\"\n:\n \n\"success\"\n,\n\n            \n\"message\"\n:\n \n\"Created new todo, taking you to it.\"\n,\n\n            \n\"title\"\n:\n \n\"Wait for it\"\n\n          \n}\n\n        \n}\n\n      \n]\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\n\n\nExchanges \n\n\nExchanges are internal hooks to external apis, to either push data and update an external service, or pull data and update itself from some external service.\n\n\nExample, use exchange to sync data creation call to Google Sheets. So on every row created using the POST API also creates a corresponding row in your google sheet.\n\n\n\n\nGoogle drive exchange YAML\n\n\nExchanges\n:\n\n\n-\n \nName\n:\n \nTask to excel sheet\n\n  \nSourceAttributes\n:\n\n    \nName\n:\n \ntodo\n\n  \nSourceType\n:\n \nself\n\n  \nTargetAttributes\n:\n\n    \nsheetUrl\n:\n \nhttps://content-sheets.googleapis.com/v4/spreadsheets/1Ru-bDk3AjQotQj72k8SyxoOs84eXA1Y6sSPumBb3WSA/values/A1:append\n\n    \nappKey\n:\n \nAIzaSyAC2xame4NShrzH9ZJeEpWT5GkySooa0XM\n\n  \nTargetType\n:\n \ngsheet-append\n\n  \nAttributes\n:\n\n  \n-\n \nSourceColumn\n:\n \n\"$self.description\"\n\n    \nTargetColumn\n:\n \nTask description\n\n  \n-\n \nSourceColumn\n:\n \nself.schedule\n\n    \nTargetColumn\n:\n \nScheduled at\n\n  \nOptions\n:\n\n    \nhasHeader\n:\n \ntrue\n\n\n\n\n\n\n\nState Machine APIs\n\n\nUsing state machine descriptions with daptin expose couple of super useful apis to manage state based data.\n\n\nEnabling \ntask_status\n state machine on \ntodo\n entity will expose the following APIs\n\n\nPOST /track/start/:stateMachineId \n{\n\"typeName\"\n: \n\"todo\"\n, \n\"referenceId\"\n: \n\"objectId\"\n}\n \n# Start tracking a particular object by id\n\n\n\n\n\nThis returns a state machine id.\n\n\nPOST /track/event/:typename/:objectStateMachineId/:eventName \n{}\n \n# Trigger event on current state\n\n\n\n\n\nThis either moves the object state to next state, or fails on invalid event name.\n\n\nExample, tracking the status of a task in a todo list, the description below describes the states it can take and the events.\n\n\n\n\nState machine description YAML\n\n\nStateMachineDescriptions\n:\n\n\n-\n \nName\n:\n \ntask_status\n\n  \nLabel\n:\n \nTask Status\n\n  \nInitialState\n:\n \nto_be_done\n\n  \nEvents\n:\n\n  \n-\n \nName\n:\n \nstart\n\n    \nLabel\n:\n \nStart\n\n    \nSrc\n:\n\n    \n-\n \nto_be_done\n\n    \n-\n \ndelayed\n\n    \nDst\n:\n \nstarted\n\n  \n-\n \nName\n:\n \ndelayed\n\n    \nLabel\n:\n \nUnable to pick up\n\n    \nSrc\n:\n\n    \n-\n \nto_be_done\n\n    \nDst\n:\n \ndelayed\n\n  \n-\n \nName\n:\n \nongoing\n\n    \nLabel\n:\n \nRecord progress\n\n    \nSrc\n:\n\n    \n-\n \nstarted\n\n    \n-\n \nongoing\n\n    \nDst\n:\n \nongoing\n\n  \n-\n \nName\n:\n \ninterrupted\n\n    \nLabel\n:\n \nInterrupted\n\n    \nSrc\n:\n\n    \n-\n \nstarted\n\n    \n-\n \nongoing\n\n    \nDst\n:\n \ninterrupted\n\n  \n-\n \nName\n:\n \nresume\n\n    \nLabel\n:\n \nResume from interruption\n\n    \nSrc\n:\n\n    \n-\n \ninterrupted\n\n    \nDst\n:\n \nongoing\n\n  \n-\n \nName\n:\n \ncompleted\n\n    \nLabel\n:\n \nMark as completed\n\n    \nSrc\n:\n\n    \n-\n \nongoing\n\n    \n-\n \nstarted\n\n    \nDst\n:\n \ncompleted\n\n\n\n\n\n\n\nUsers and access\n\n\n\n\nRequests \nwithout\n a valid \nAuthorization Bearer\n \ntoken\n will be referred to as \"guests requests\". Requests with a valid token will have an identified user.\n\n\nUser registration API\n\n\nSign up action can be allowed to guests to allow open registration by anyone. Users with enough permission over the \nuser\n table can create users manually.\n\n\nUsers registered using signup action are their own owners. Hence they can update and delete themselves. These permission can be changed based on the use case.\n\n\n\n\nPOST call for user registration\n\n\ncurl \n'http://api.daptin.com:6336/action/user/signup'\n \n\\\n\n-H \n'Authorization: Bearer null'\n \n\\\n\n-H \n'Content-Type: application/json;charset=UTF-8'\n \n\\\n\n-H \n'Accept: application/json, text/plain, */*'\n \n\\\n\n--data-binary \n'{\"attributes\":{\"name\":\"username\",\"email\":\"<UserEmail>\",\"password\":\"<Password>\",\"passwordConfirm\":\"<Password>\"}}'\n \n\n\n\n\n\n\nYou can either allow guests to be able to invoke \nsign up\n action or allow only a particular user to be able to create new users or a usergroup.\n\n\n[\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.notify\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"message\"\n:\n \n\"Created user\"\n,\n\n      \n\"title\"\n:\n \n\"Success\"\n,\n\n      \n\"type\"\n:\n \n\"success\"\n\n    \n}\n\n  \n}\n\n\n]\n\n\n\n\n\nThis user can sign in now (generate an auth token). But what he can access is again based on the permission of the system.\n\n\nUser sign in API\n\n\n\n\nPOST call for sign in\n\n\ncurl \n'http://api.daptin.com:6336/action/user/signin'\n \n\\\n\n-H \n'Content-Type: application/json;charset=UTF-8'\n \n\\\n\n-H \n'Accept: application/json, text/plain, */*'\n \n\\\n\n--data-binary \n'{\"attributes\":{\"email\":\"<Email>\",\"password\":\"<Password>\"}}'\n\n\n\n\n\n\n\n[\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.store.set\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"key\"\n:\n \n\"token\"\n,\n\n      \n\"value\"\n:\n \n\"<AccessToken>\"\n\n    \n}\n\n  \n},\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.notify\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"message\"\n:\n \n\"Logged in\"\n,\n\n      \n\"title\"\n:\n \n\"Success\"\n,\n\n      \n\"type\"\n:\n \n\"success\"\n\n    \n}\n\n  \n},\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.redirect\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"delay\"\n:\n \n2000\n,\n\n      \n\"location\"\n:\n \n\"/\"\n,\n\n      \n\"window\"\n:\n \n\"self\"\n\n    \n}\n\n  \n}\n\n\n]\n\n\n\n\n\nHost static sites\n\n\n\n\nExpose folders on cloud storage services as websites using your daptin instance.\n\n\n\n\nNew subsite\n\n\n\n\nSelect a cloud storage\n\n\nChoose a domain/sub-domain\n\n\nChoose a sub-path\n\n\n\n\n\n\nRestart is required to reflect changes.\n\n\nData auditing\n\n\nTo enable recoding of all historical data for a particular entity, enable data audit for it in the worlds configuration.\n\n\nAudits are ready only and cannot be manipulated over api. You can configure the permission for your use case.\n\n\nOAuth Connection\n\n\n\n\nConnecting to your cloud storage and external services requires authentication, OAuth covers a large number of those services.\n\n\nConcepts\n\n\nData\n\n\n\n\nData storage and table structures\n\n\nAuditing\n\n\nData validations\n\n\nData conformations\n\n\nState tracking for entities\n\n\n\n\nActions and streams\n\n\n\n\nActions\n\n\nData streams\n\n\nOauth connections\n\n\nOauth tokens\n\n\n\n\nAuthentication and Authorization\n\n\n\n\nUsers and user groups\n\n\nAuthentication\n\n\nAuthorization\n\n\nPermissions\n\n\n\n\nExternal APIs and integrations\n\n\n\n\nInteracting with third party APIs\n\n\nStorage connectors\n\n\n\n\nSub-sites, Marketplace\n\n\n\n\nSub sites\n\n\nJson schemas",
            "title": "Home"
        },
        {
            "location": "/#daptin",
            "text": "",
            "title": "DAPTIN"
        },
        {
            "location": "/#create-an-instance",
            "text": "",
            "title": "Create an instance"
        },
        {
            "location": "/#import-data",
            "text": "",
            "title": "Import data"
        },
        {
            "location": "/#upload-from-dashboard",
            "text": "Upload one of these files:     File  Usage      Schema JSON  Create schema and apis    CSV  Auto create entity and upload data    XLSX  Auto create entity and upload data    Data JSON  Upload data from dumps",
            "title": "Upload from dashboard"
        },
        {
            "location": "/#tables",
            "text": "Tables are the basic data structure. Tables have columns. Each column has a particular data type. These tables are exposed over APIs under the  /api/  path. Checkout  entity documentation  for details.   YAML example  Tables :  -   TableName :   todo \n   Columns : \n   -   Name :   title \n     DataType :   varchar(500) \n     ColumnType :   label \n     IsIndexed :   true     JSON example  { \n   \"Tables\" :   [ \n     { \n       \"TableName\" :   \"todo\" , \n       \"Columns\" :   [ \n         { \n           \"Name\" :   \"title\" , \n           \"DataType\" :   \"varchar(500)\" , \n           \"ColumnType\" :   \"label\" , \n           \"IsIndexed\" :   true \n         } \n       ] \n     } \n   ]  }",
            "title": "Tables"
        },
        {
            "location": "/#relations",
            "text": "Relations are constraints among tables and help you keep clean and consistent data. Relational data is easily accessible over APIs using a path structure like  /api/<entityName>/<id>/<relationName>  and the response is consistent with  JSONAPI.org .   YAML example  Relations :  -   Subject :   todo \n   Relation :   has_one \n   Object :   project     JSON example  { \n   \"Relations\" :   [ \n     { \n       \"Subject\" :   \"todo\" , \n       \"Relation\" :   \"has_one\" , \n       \"Object\" :   \"project\" \n     } \n   ]  }",
            "title": "Relations"
        },
        {
            "location": "/#actions",
            "text": "Actions are entity dependent APIs which you want to expose which may have an outcome of events. Most basic example is the login action which generates an oauth2 token as an outcome.  Use action to expose endpoints for your forms and processes. Here is an example of creating a \"/action/project/new_task\" API:   New task action YAML  Actions :  -   Name :   new_task \n   Label :   New to do \n   OnType :   project \n   InstanceOptional :   true \n   InFields : \n   -   ColumnName :   description \n     Name :   Description \n     ColumnType :   label \n   -   ColumnName :   schedule \n     Name :   Scheduled at \n     ColumnType :   date \n   OutFields : \n   -   Type :   todo \n     Method :   POST \n     Attributes : \n       schedule :   \"~schedule\" \n       title :   \"~description\" \n       project_id :   \"$.reference_id\" \n   -   Type :   client.notify \n     Method :   ACTIONRESPONSE \n     Attributes : \n       type :   success \n       message :   Created new todo, taking you to it. \n       title :   Wait for it     New task action JSON  { \n   \"Actions\" :   [ \n     { \n       \"Name\" :   \"new_task\" , \n       \"Label\" :   \"New to do\" , \n       \"OnType\" :   \"project\" , \n       \"InstanceOptional\" :   true , \n       \"InFields\" :   [ \n         { \n           \"ColumnName\" :   \"description\" , \n           \"Name\" :   \"Description\" , \n           \"ColumnType\" :   \"label\" \n         }, \n         { \n           \"ColumnName\" :   \"schedule\" , \n           \"Name\" :   \"Scheduled at\" , \n           \"ColumnType\" :   \"date\" \n         } \n       ], \n       \"OutFields\" :   [ \n         { \n           \"Type\" :   \"todo\" , \n           \"Method\" :   \"POST\" , \n           \"Attributes\" :   { \n             \"schedule\" :   \"~schedule\" , \n             \"title\" :   \"~description\" , \n             \"project_id\" :   \"$.reference_id\" \n           } \n         }, \n         { \n           \"Type\" :   \"client.notify\" , \n           \"Method\" :   \"ACTIONRESPONSE\" , \n           \"Attributes\" :   { \n             \"type\" :   \"success\" , \n             \"message\" :   \"Created new todo, taking you to it.\" , \n             \"title\" :   \"Wait for it\" \n           } \n         } \n       ] \n     } \n   ]  }",
            "title": "Actions"
        },
        {
            "location": "/#exchanges",
            "text": "Exchanges are internal hooks to external apis, to either push data and update an external service, or pull data and update itself from some external service.  Example, use exchange to sync data creation call to Google Sheets. So on every row created using the POST API also creates a corresponding row in your google sheet.   Google drive exchange YAML  Exchanges :  -   Name :   Task to excel sheet \n   SourceAttributes : \n     Name :   todo \n   SourceType :   self \n   TargetAttributes : \n     sheetUrl :   https://content-sheets.googleapis.com/v4/spreadsheets/1Ru-bDk3AjQotQj72k8SyxoOs84eXA1Y6sSPumBb3WSA/values/A1:append \n     appKey :   AIzaSyAC2xame4NShrzH9ZJeEpWT5GkySooa0XM \n   TargetType :   gsheet-append \n   Attributes : \n   -   SourceColumn :   \"$self.description\" \n     TargetColumn :   Task description \n   -   SourceColumn :   self.schedule \n     TargetColumn :   Scheduled at \n   Options : \n     hasHeader :   true",
            "title": "Exchanges "
        },
        {
            "location": "/#state-machine-apis",
            "text": "Using state machine descriptions with daptin expose couple of super useful apis to manage state based data.  Enabling  task_status  state machine on  todo  entity will expose the following APIs  POST /track/start/:stateMachineId  { \"typeName\" :  \"todo\" ,  \"referenceId\" :  \"objectId\" }   # Start tracking a particular object by id   This returns a state machine id.  POST /track/event/:typename/:objectStateMachineId/:eventName  {}   # Trigger event on current state   This either moves the object state to next state, or fails on invalid event name.  Example, tracking the status of a task in a todo list, the description below describes the states it can take and the events.   State machine description YAML  StateMachineDescriptions :  -   Name :   task_status \n   Label :   Task Status \n   InitialState :   to_be_done \n   Events : \n   -   Name :   start \n     Label :   Start \n     Src : \n     -   to_be_done \n     -   delayed \n     Dst :   started \n   -   Name :   delayed \n     Label :   Unable to pick up \n     Src : \n     -   to_be_done \n     Dst :   delayed \n   -   Name :   ongoing \n     Label :   Record progress \n     Src : \n     -   started \n     -   ongoing \n     Dst :   ongoing \n   -   Name :   interrupted \n     Label :   Interrupted \n     Src : \n     -   started \n     -   ongoing \n     Dst :   interrupted \n   -   Name :   resume \n     Label :   Resume from interruption \n     Src : \n     -   interrupted \n     Dst :   ongoing \n   -   Name :   completed \n     Label :   Mark as completed \n     Src : \n     -   ongoing \n     -   started \n     Dst :   completed",
            "title": "State Machine APIs"
        },
        {
            "location": "/#users-and-access",
            "text": "Requests  without  a valid  Authorization Bearer   token  will be referred to as \"guests requests\". Requests with a valid token will have an identified user.",
            "title": "Users and access"
        },
        {
            "location": "/#user-registration-api",
            "text": "Sign up action can be allowed to guests to allow open registration by anyone. Users with enough permission over the  user  table can create users manually.  Users registered using signup action are their own owners. Hence they can update and delete themselves. These permission can be changed based on the use case.   POST call for user registration  curl  'http://api.daptin.com:6336/action/user/signup'   \\ \n-H  'Authorization: Bearer null'   \\ \n-H  'Content-Type: application/json;charset=UTF-8'   \\ \n-H  'Accept: application/json, text/plain, */*'   \\ \n--data-binary  '{\"attributes\":{\"name\":\"username\",\"email\":\"<UserEmail>\",\"password\":\"<Password>\",\"passwordConfirm\":\"<Password>\"}}'     You can either allow guests to be able to invoke  sign up  action or allow only a particular user to be able to create new users or a usergroup.  [ \n   { \n     \"ResponseType\" :   \"client.notify\" , \n     \"Attributes\" :   { \n       \"message\" :   \"Created user\" , \n       \"title\" :   \"Success\" , \n       \"type\" :   \"success\" \n     } \n   }  ]   This user can sign in now (generate an auth token). But what he can access is again based on the permission of the system.",
            "title": "User registration API"
        },
        {
            "location": "/#user-sign-in-api",
            "text": "POST call for sign in  curl  'http://api.daptin.com:6336/action/user/signin'   \\ \n-H  'Content-Type: application/json;charset=UTF-8'   \\ \n-H  'Accept: application/json, text/plain, */*'   \\ \n--data-binary  '{\"attributes\":{\"email\":\"<Email>\",\"password\":\"<Password>\"}}'    [ \n   { \n     \"ResponseType\" :   \"client.store.set\" , \n     \"Attributes\" :   { \n       \"key\" :   \"token\" , \n       \"value\" :   \"<AccessToken>\" \n     } \n   }, \n   { \n     \"ResponseType\" :   \"client.notify\" , \n     \"Attributes\" :   { \n       \"message\" :   \"Logged in\" , \n       \"title\" :   \"Success\" , \n       \"type\" :   \"success\" \n     } \n   }, \n   { \n     \"ResponseType\" :   \"client.redirect\" , \n     \"Attributes\" :   { \n       \"delay\" :   2000 , \n       \"location\" :   \"/\" , \n       \"window\" :   \"self\" \n     } \n   }  ]",
            "title": "User sign in API"
        },
        {
            "location": "/#host-static-sites",
            "text": "Expose folders on cloud storage services as websites using your daptin instance.   New subsite   Select a cloud storage  Choose a domain/sub-domain  Choose a sub-path    Restart is required to reflect changes.",
            "title": "Host static sites"
        },
        {
            "location": "/#data-auditing",
            "text": "To enable recoding of all historical data for a particular entity, enable data audit for it in the worlds configuration.  Audits are ready only and cannot be manipulated over api. You can configure the permission for your use case.",
            "title": "Data auditing"
        },
        {
            "location": "/#oauth-connection",
            "text": "Connecting to your cloud storage and external services requires authentication, OAuth covers a large number of those services.",
            "title": "OAuth Connection"
        },
        {
            "location": "/#concepts",
            "text": "",
            "title": "Concepts"
        },
        {
            "location": "/#data",
            "text": "Data storage and table structures  Auditing  Data validations  Data conformations  State tracking for entities",
            "title": "Data"
        },
        {
            "location": "/#actions-and-streams",
            "text": "Actions  Data streams  Oauth connections  Oauth tokens",
            "title": "Actions and streams"
        },
        {
            "location": "/#authentication-and-authorization",
            "text": "Users and user groups  Authentication  Authorization  Permissions",
            "title": "Authentication and Authorization"
        },
        {
            "location": "/#external-apis-and-integrations",
            "text": "Interacting with third party APIs  Storage connectors",
            "title": "External APIs and integrations"
        },
        {
            "location": "/#sub-sites-marketplace",
            "text": "Sub sites  Json schemas",
            "title": "Sub-sites, Marketplace"
        },
        {
            "location": "/setting-up/settingup/",
            "text": "Setting up Daptin\n\n\nDaptin is built in golang and a static artifact is available for most targets\n\n\nDeploy and get started\n\n\n\n\n\n\n\n\nDeployment preference\n\n\nGetting started\n\n\n\n\n\n\n\n\n\n\nHeroku\n\n\n\n\n\n\n\n\nDocker\n\n\ndocker run -p 8080:8080 daptin/daptin\n\n\n\n\n\n\nKubernetes\n\n\nService & Deployment YAML\n\n\n\n\n\n\nLocal\n\n\ngo get github.com/daptin/daptin\n\n\n\n\n\n\nLinux (386/amd64/arm5,6,7)\n\n\nDownload static linux builds\n\n\n\n\n\n\nWindows\n\n\ngo get github.com/daptin/daptin\n\n\n\n\n\n\nOS X\n\n\ngo get github.com/daptin/daptin\n\n\n\n\n\n\nLoad testing\n\n\nDocker compose\n\n\n\n\n\n\nRaspberry Pi\n\n\nLinux arm 7 static build\n\n\n\n\n\n\n\n\nNative binary\n\n\nDaptin is available as a native binary. You can fetch the lastest binary from the releases\n\n\nhttps://github.com/daptin/daptin/releases\n\n\nTo start daptin, execute \n./daptin\n which will create a local sqlite database and start listening on port 6336. To change the database or port, read below.\n\n\nDocker image\n\n\nDeploy the docker image is on any docker compatible hosting provider (aws, gce, linode, digitalocean, azure)\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://hub.docker.com/r/daptin/daptin/\n\n\nTo start daptin on your local machine using docker\n\n\ndocker run -p 8080:8080 daptin/daptin\n\n\nDocker compose\n\n\nDocker compose is a great way to bring up a mysql/postgres instance backed daptin\n\n\nversion\n:\n \n'3'\n\n\nservices\n:\n\n    \nweb\n:\n\n        \nimage\n:\n \ndaptin/daptin\n\n        \nports\n:\n\n            \n-\n \n\"8090:8080\"\n\n        \nrestart\n:\n \nalways\n\n        \nenvironment\n:\n\n          \nDAPTIN_PORT\n:\n \n'8080'\n\n          \nDAPTIN_DB_TYPE\n:\n \n'mysql'\n\n          \nDAPTIN_DB_CONNECTION_STRING\n:\n \n'dev:dev@tcp(mysqldb:3306)/daptin'\n\n        \ndepends_on\n:\n\n            \n-\n \nmysqldb\n\n    \nmysqldb\n:\n\n        \nimage\n:\n \nmysql\n\n        \ncontainer_name\n:\n \n${MYSQL_HOST}\n\n        \nrestart\n:\n \nalways\n\n        \nenv_file\n:\n\n            \n-\n \n\".env\"\n\n        \nenvironment\n:\n\n            \n-\n \nMYSQL_DATABASE=${MYSQL_DATABASE}\n\n            \n-\n \nMYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n\n            \n-\n \nMYSQL_USER=${MYSQL_USER}\n\n            \n-\n \nMYSQL_PASSWORD=${MYSQL_PASSWORD}\n\n        \nports\n:\n\n            \n-\n \n\"8989:3306\"\n\n        \nvolumes\n:\n\n            \n-\n \n\"./data/db/mysql:/var/lib/mysql\"\n\n\n\n\n\nKubernetes deployment\n\n\nDaptin can be infinitely scaled on kubernetes\n\n\napiVersion\n:\n \nv1\n\n\nkind\n:\n \nService\n\n\nmetadata\n:\n\n  \nname\n:\n \ndaptin-instance\n\n  \nlabels\n:\n\n    \napp\n:\n \ndaptin\n\n\nspec\n:\n\n  \nports\n:\n\n    \n-\n \nport\n:\n \n8080\n\n  \nselector\n:\n\n    \napp\n:\n \ndaptin\n\n    \ntier\n:\n \nproduction\n\n\n---\n\n\napiVersion\n:\n \nextensions/v1beta1\n\n\nkind\n:\n \nDeployment\n\n\nmetadata\n:\n\n  \nname\n:\n \ndaptin-daptin\n\n  \nlabels\n:\n\n    \napp\n:\n \ndaptin\n\n\nspec\n:\n\n  \nstrategy\n:\n\n    \ntype\n:\n \nRecreate\n\n  \ntemplate\n:\n\n    \nmetadata\n:\n\n      \nlabels\n:\n\n        \napp\n:\n \ndaptin\n\n        \ntier\n:\n \ntesting\n\n    \nspec\n:\n\n      \ncontainers\n:\n\n      \n-\n \nimage\n:\n \ndaptin/daptin:latest\n\n        \nname\n:\n \ndaptin\n\n        \nargs\n:\n \n[\n'-db_type'\n,\n \n'mysql'\n,\n \n'-db_connection_string'\n,\n \n'user:password@tcp(<mysql_service>:3306)/daptin'\n]\n\n        \nports\n:\n\n        \n-\n \ncontainerPort\n:\n \n8080\n\n          \nname\n:\n \ndaptin\n\n\n---\n\n\napiVersion\n:\n \nextensions/v1beta1\n\n\nkind\n:\n \nIngress\n\n\nmetadata\n:\n\n  \nname\n:\n \ndaptin-test\n\n\nspec\n:\n\n  \nrules\n:\n\n  \n-\n \nhost\n:\n \nhello.website\n\n    \nhttp\n:\n\n      \npaths\n:\n\n      \n-\n \nbackend\n:\n\n          \nserviceName\n:\n \ndaptin-testing\n\n          \nservicePort\n:\n \n8080\n\n\n\n\n\nDatabase and data persistence\n\n\nDaptin can use one of the following database for data persistence\n\n\n\n\nMysql\n\n\nPostgres\n\n\nSQLite [Default]\n\n\n\n\nIf nothing specified, a sqlite database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)\n\n\nYou can customise the database connection properties when starting daptin\n\n\nmysql\n\n\nTo use mysql, start daptin as follows\n\n\n./daptin -db_type=mysql -db_connection_string='<username>:<password>@tcp(<hostname>:<port>)/<db_name>'\n\n\npostgres\n\n\n./daptin -db_type=postgres -db_connection_string='host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable'\n\n\nsqlite\n\n\nBy default a \"daptin.db\" file is created to store data\n\n\n./daptin -db_type=sqlite -db_connection_string=db_file_name.db\n\n\nPort\n\n\nDaptin will listen on port 6336 by default. You can change it by using the following argument\n\n\n-port=8080\n\n\nRestart\n\n\nDaptin relies on self restarts to configure new entities and apis and changes to the other parts of the ststem. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.\n\n\nYou can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.",
            "title": "Setting up"
        },
        {
            "location": "/setting-up/settingup/#setting-up-daptin",
            "text": "Daptin is built in golang and a static artifact is available for most targets",
            "title": "Setting up Daptin"
        },
        {
            "location": "/setting-up/settingup/#deploy-and-get-started",
            "text": "Deployment preference  Getting started      Heroku     Docker  docker run -p 8080:8080 daptin/daptin    Kubernetes  Service & Deployment YAML    Local  go get github.com/daptin/daptin    Linux (386/amd64/arm5,6,7)  Download static linux builds    Windows  go get github.com/daptin/daptin    OS X  go get github.com/daptin/daptin    Load testing  Docker compose    Raspberry Pi  Linux arm 7 static build",
            "title": "Deploy and get started"
        },
        {
            "location": "/setting-up/settingup/#native-binary",
            "text": "Daptin is available as a native binary. You can fetch the lastest binary from the releases  https://github.com/daptin/daptin/releases  To start daptin, execute  ./daptin  which will create a local sqlite database and start listening on port 6336. To change the database or port, read below.",
            "title": "Native binary"
        },
        {
            "location": "/setting-up/settingup/#docker-image",
            "text": "Deploy the docker image is on any docker compatible hosting provider (aws, gce, linode, digitalocean, azure)       https://hub.docker.com/r/daptin/daptin/  To start daptin on your local machine using docker  docker run -p 8080:8080 daptin/daptin",
            "title": "Docker image"
        },
        {
            "location": "/setting-up/settingup/#docker-compose",
            "text": "Docker compose is a great way to bring up a mysql/postgres instance backed daptin  version :   '3'  services : \n     web : \n         image :   daptin/daptin \n         ports : \n             -   \"8090:8080\" \n         restart :   always \n         environment : \n           DAPTIN_PORT :   '8080' \n           DAPTIN_DB_TYPE :   'mysql' \n           DAPTIN_DB_CONNECTION_STRING :   'dev:dev@tcp(mysqldb:3306)/daptin' \n         depends_on : \n             -   mysqldb \n     mysqldb : \n         image :   mysql \n         container_name :   ${MYSQL_HOST} \n         restart :   always \n         env_file : \n             -   \".env\" \n         environment : \n             -   MYSQL_DATABASE=${MYSQL_DATABASE} \n             -   MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} \n             -   MYSQL_USER=${MYSQL_USER} \n             -   MYSQL_PASSWORD=${MYSQL_PASSWORD} \n         ports : \n             -   \"8989:3306\" \n         volumes : \n             -   \"./data/db/mysql:/var/lib/mysql\"",
            "title": "Docker compose"
        },
        {
            "location": "/setting-up/settingup/#kubernetes-deployment",
            "text": "Daptin can be infinitely scaled on kubernetes  apiVersion :   v1  kind :   Service  metadata : \n   name :   daptin-instance \n   labels : \n     app :   daptin  spec : \n   ports : \n     -   port :   8080 \n   selector : \n     app :   daptin \n     tier :   production  ---  apiVersion :   extensions/v1beta1  kind :   Deployment  metadata : \n   name :   daptin-daptin \n   labels : \n     app :   daptin  spec : \n   strategy : \n     type :   Recreate \n   template : \n     metadata : \n       labels : \n         app :   daptin \n         tier :   testing \n     spec : \n       containers : \n       -   image :   daptin/daptin:latest \n         name :   daptin \n         args :   [ '-db_type' ,   'mysql' ,   '-db_connection_string' ,   'user:password@tcp(<mysql_service>:3306)/daptin' ] \n         ports : \n         -   containerPort :   8080 \n           name :   daptin  ---  apiVersion :   extensions/v1beta1  kind :   Ingress  metadata : \n   name :   daptin-test  spec : \n   rules : \n   -   host :   hello.website \n     http : \n       paths : \n       -   backend : \n           serviceName :   daptin-testing \n           servicePort :   8080",
            "title": "Kubernetes deployment"
        },
        {
            "location": "/setting-up/settingup/#database-and-data-persistence",
            "text": "Daptin can use one of the following database for data persistence   Mysql  Postgres  SQLite [Default]   If nothing specified, a sqlite database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)  You can customise the database connection properties when starting daptin",
            "title": "Database and data persistence"
        },
        {
            "location": "/setting-up/settingup/#mysql",
            "text": "To use mysql, start daptin as follows  ./daptin -db_type=mysql -db_connection_string='<username>:<password>@tcp(<hostname>:<port>)/<db_name>'",
            "title": "mysql"
        },
        {
            "location": "/setting-up/settingup/#postgres",
            "text": "./daptin -db_type=postgres -db_connection_string='host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable'",
            "title": "postgres"
        },
        {
            "location": "/setting-up/settingup/#sqlite",
            "text": "By default a \"daptin.db\" file is created to store data  ./daptin -db_type=sqlite -db_connection_string=db_file_name.db",
            "title": "sqlite"
        },
        {
            "location": "/setting-up/settingup/#port",
            "text": "Daptin will listen on port 6336 by default. You can change it by using the following argument  -port=8080",
            "title": "Port"
        },
        {
            "location": "/setting-up/settingup/#restart",
            "text": "Daptin relies on self restarts to configure new entities and apis and changes to the other parts of the ststem. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.  You can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.",
            "title": "Restart"
        },
        {
            "location": "/setting-up/entities/",
            "text": "Entites\n\n\nImport CSV or XLS file and you can let Daptin create the entities for you based on intelligent data pre-processor.\n\n\nIf you are looking for a more reproducible way, design your entities and create JSON or YAML files. These files can be used again to create an exact same replica.\n\n\nMultiple schema json files can be uploaded, and changes are merged accordingly.\n\n\nLets imagine we were creating a todo application and wanted to keep a track the following for each todo item\n\n\n\n\nTo do list example\n\n\n\n\nthe todo text field - title\n\n\na description text field - may or may not be empty\n\n\na deadline date field - a date field to capture the deadline\n\n\ncompleted - a true/false field, which captures if the todo is done\n\n\norder - a field to store the priority of each todo\n\n\n\n\n\n\nAlong with the fields mentioned above, we might want certain validations and conformations whenever we store a new todo\n\n\n\n\ntitle cannot be empty\n\n\norder has to be numeric\n\n\n\n\nOnce we have come up with the above picture in mind, we can use one of the following ways to tell daptin about this:\n\n\nOnline entity designer\n\n\nThe entity designer is accessible from dashboard using the \"Online designer\" button. Here you can set the name, add columns and relations and create it. This is a basic designer and more advanced features to customise every aspect of the entity will be added later.\n\n\n\n\nMarket place\n\n\nCheckout \nmarketplace documentation\n\n\nJSON / YAML files\n\n\nJSON/YAML files are the primary way to create new entites in daptin. The above two ways ultimatele create a JSON file or fetch from the market.\n\n\nThe JSON for our hypothetical todo entity will look as follows:\n\n\n    \n{\n\n        \n\"Tables\"\n:\n \n[{\n\n            \n\"TableName\"\n:\n \n\"todo\"\n,\n\n            \n\"Columns\"\n:\n \n[{\n\n                    \n\"Name\"\n:\n \n\"title\"\n,\n\n                    \n\"DataType\"\n:\n \n\"varchar(500)\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"label\"\n,\n\n                    \n\"IsIndexed\"\n:\n \ntrue\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"completed\"\n,\n\n                    \n\"DataType\"\n:\n \n\"int(1)\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"truefalse\"\n,\n\n                    \n\"DefaultValue\"\n:\n \n\"false\"\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"deadline\"\n,\n\n                    \n\"DataType\"\n:\n \n\"date\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"date\"\n,\n\n                    \n\"IsNullable\"\n:\n \ntrue\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"order\"\n,\n\n                    \n\"ColumnName\"\n:\n \n\"item_order\"\n,\n\n                    \n\"DataType\"\n:\n \n\"int(4)\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"measurement\"\n,\n\n                    \n\"DefaultValue\"\n:\n \n\"10\"\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"text\"\n,\n\n                    \n\"DataType\"\n:\n \n\"text\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"content\"\n,\n\n                    \n\"IsNullable\"\n:\n \ntrue\n\n                \n}\n\n            \n],\n\n            \n\"Conformations\"\n:\n \n[{\n\n                \n\"ColumnName\"\n:\n \n\"order\"\n,\n\n                \n\"Tags\"\n:\n \n\"numeric\"\n\n            \n}],\n\n            \n\"validations\"\n:\n \n[{\n\n                \n\"ColumnName\"\n:\n \n\"title\"\n,\n\n                \n\"Tags\"\n:\n \n\"required\"\n\n            \n}]\n\n\n]\n}\n\n\n\n\n\n\n\nName: Name is a human readable name\n\n\nColumn Name: Name of the column in the table\n\n\nColumn Type: The type of the column. Daptin supports a variety of types and these allow daptin to give you useful options in future (eg for viewing a timeline, a date/datetime column is required)\n\n\nDefault value: Columns can have default values, which is used a new row is created and no value for that column is specified.\n\n\n\n\nWhile the same description in YAML will look as follows\n\n\nTables\n:\n\n\n-\n \nTableName\n:\n \ntodo\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(500)\n\n    \nColumnType\n:\n \nlabel\n\n    \nIsIndexed\n:\n \ntrue\n\n  \n-\n \nName\n:\n \nurl\n\n    \nDataType\n:\n \nvarchar(200)\n\n    \nColumnType\n:\n \nurl\n\n    \nIsNullable\n:\n \ntrue\n\n  \n-\n \nName\n:\n \ncompleted\n\n    \nDataType\n:\n \nint(1)\n\n    \nColumnType\n:\n \ntruefalse\n\n    \nDefaultValue\n:\n \n'false'\n\n  \n-\n \nName\n:\n \nschedule\n\n    \nDataType\n:\n \ndate\n\n    \nColumnType\n:\n \ndate\n\n    \nIsNullable\n:\n \ntrue\n\n  \n-\n \nName\n:\n \norder\n\n    \nColumnName\n:\n \nitem_order\n\n    \nDataType\n:\n \nint(4)\n\n    \nColumnType\n:\n \nmeasurement\n\n    \nDefaultValue\n:\n \n'10'\n\n  \n-\n \nName\n:\n \ntext\n\n    \nDataType\n:\n \ntext\n\n    \nColumnType\n:\n \ncontent\n\n    \nIsNullable\n:\n \ntrue\n\n  \nConformations\n:\n\n  \n-\n \nColumnName\n:\n \norder\n\n    \nTags\n:\n \nnumeric\n\n  \nValidations\n:\n\n  \n-\n \nColumnName\n:\n \ntitle\n\n\nTags\n:\n \nrequired\n\n\n\n\n\nYou can choose to work with either json or yaml. Once the schema is ready, it can be uploaded directly from daptin dashboard.\n\n\nColumn specifications\n\n\nColumns of the entity can be cusomised:\n\n\n\n\n\n\n\n\nProperty Name\n\n\nProperty Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nName\n\n\nstring\n\n\nhuman readable name, can be skipped\n\n\n\n\n\n\nColumnName\n\n\nstring\n\n\ncolumn name in the table\n\n\n\n\n\n\nColumnDescription\n\n\nstring\n\n\nhuman readable description\n\n\n\n\n\n\nColumnType\n\n\nstring\n\n\ncolumn type is a rich type of the column\n\n\n\n\n\n\nIsIndexed\n\n\nboolean\n\n\ntrue to add an index on this column\n\n\n\n\n\n\nIsUnique\n\n\nboolean\n\n\ntrue to set a unique constraint on this column\n\n\n\n\n\n\nIsNullable\n\n\nboolean\n\n\nare null values allowed\n\n\n\n\n\n\nPermission\n\n\nuint64\n\n\npermission column (check authorization docs)\n\n\n\n\n\n\nDataType\n\n\nstring\n\n\nthe column type inside the database\n\n\n\n\n\n\nDefaultValue\n\n\nstring\n\n\ndefault value if any (has to be inside single quotes for static values\n\n\n\n\n\n\n\n\nColumn types\n\n\nDaptin supports a variety of rich data types, which helps it to automatically make intelligent decisions and validations. Here is a list of all column types and what should they be used for\n\n\n\n\n\n\n\n\nType Name\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nid\n\n\nan identity column, mostly for internal purposes\n\n\n1\n\n\n\n\n\n\nalias\n\n\na foreign key column\n\n\nuuid v4\n\n\n\n\n\n\ndate\n\n\nfull date, no time\n\n\n2017-12-30\n\n\n\n\n\n\ntime\n\n\ntime/time interval, no date\n\n\n12:34:54\n\n\n\n\n\n\nday\n\n\nday of the month\n\n\n1 to 31\n\n\n\n\n\n\nmonth\n\n\nmonth of the year\n\n\n1 to 12\n\n\n\n\n\n\nyear\n\n\nYear\n\n\n2017\n\n\n\n\n\n\nminute\n\n\nminute of the hour\n\n\n0 to 59\n\n\n\n\n\n\nhour\n\n\nhour of the dat\n\n\n0 - 23\n\n\n\n\n\n\ndatetime\n\n\ndate + time (not stored as timestamp, served at date time string)\n\n\n2017-12-30T12:34:54\n\n\n\n\n\n\nemail\n\n\nemail\n\n\ntest@domain.com\n\n\n\n\n\n\nname\n\n\ncolumn to be used as name of the entity\n\n\ndaptin\n\n\n\n\n\n\njson\n\n\nJSON data\n\n\n{}\n\n\n\n\n\n\npassword\n\n\npassword - are bcrypted with cost 11\n\n\n$2a$11$z/VlxycDgZ...\n\n\n\n\n\n\nvalue\n\n\nvalue is enumeration type\n\n\ncompleted\n\n\n\n\n\n\ntruefalse\n\n\nboolean\n\n\n1\n\n\n\n\n\n\ntimestamp\n\n\ntimestamp (stored as timestamp, served as timestamp)\n\n\n123123123\n\n\n\n\n\n\nlocation.latitude\n\n\nonly latitude\n\n\n34.2938\n\n\n\n\n\n\nlocation\n\n\nlatitude + longitude in geoJson format\n\n\n[34.223,64.123]\n\n\n\n\n\n\nlocation.longitude\n\n\nonly longitude\n\n\n64.123\n\n\n\n\n\n\nlocation.altitude\n\n\nonly altitude\n\n\n34\n\n\n\n\n\n\ncolor\n\n\nhex color string\n\n\n#ABCDE1\n\n\n\n\n\n\nrating.10\n\n\nrating on a scale of 10\n\n\n8\n\n\n\n\n\n\nmeasurement\n\n\nnumeric column\n\n\n534\n\n\n\n\n\n\nlabel\n\n\na label for the entity, similar to name but can be more than one\n\n\nred\n\n\n\n\n\n\ncontent\n\n\nlarger contents - texts/html/json/yaml\n\n\nvery long text\n\n\n\n\n\n\nfile\n\n\nuploads, connect storage for using this\n\n\n\n\n\n\n\n\nurl\n\n\nUrls/links\n\n\nhttp://docs.dapt.in\n\n\n\n\n\n\n\n\nExcel file upload\n\n\nExcel upload provides an easy way to create entities. This takes away the complexity of writing each column type. Daptin uses a combination of rules to identify columns and their types based on the data in the excel.\n\n\nYou can upload data from XLS. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.\n\n\nRestart\n\n\nDaptin relies on self restarts to configure new entities and apis. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.\n\n\nYou can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.",
            "title": "Entities"
        },
        {
            "location": "/setting-up/entities/#entites",
            "text": "Import CSV or XLS file and you can let Daptin create the entities for you based on intelligent data pre-processor.  If you are looking for a more reproducible way, design your entities and create JSON or YAML files. These files can be used again to create an exact same replica.  Multiple schema json files can be uploaded, and changes are merged accordingly.  Lets imagine we were creating a todo application and wanted to keep a track the following for each todo item   To do list example   the todo text field - title  a description text field - may or may not be empty  a deadline date field - a date field to capture the deadline  completed - a true/false field, which captures if the todo is done  order - a field to store the priority of each todo    Along with the fields mentioned above, we might want certain validations and conformations whenever we store a new todo   title cannot be empty  order has to be numeric   Once we have come up with the above picture in mind, we can use one of the following ways to tell daptin about this:",
            "title": "Entites"
        },
        {
            "location": "/setting-up/entities/#online-entity-designer",
            "text": "The entity designer is accessible from dashboard using the \"Online designer\" button. Here you can set the name, add columns and relations and create it. This is a basic designer and more advanced features to customise every aspect of the entity will be added later.",
            "title": "Online entity designer"
        },
        {
            "location": "/setting-up/entities/#market-place",
            "text": "Checkout  marketplace documentation",
            "title": "Market place"
        },
        {
            "location": "/setting-up/entities/#json-yaml-files",
            "text": "JSON/YAML files are the primary way to create new entites in daptin. The above two ways ultimatele create a JSON file or fetch from the market.  The JSON for our hypothetical todo entity will look as follows:       { \n         \"Tables\" :   [{ \n             \"TableName\" :   \"todo\" , \n             \"Columns\" :   [{ \n                     \"Name\" :   \"title\" , \n                     \"DataType\" :   \"varchar(500)\" , \n                     \"ColumnType\" :   \"label\" , \n                     \"IsIndexed\" :   true \n                 }, \n                 { \n                     \"Name\" :   \"completed\" , \n                     \"DataType\" :   \"int(1)\" , \n                     \"ColumnType\" :   \"truefalse\" , \n                     \"DefaultValue\" :   \"false\" \n                 }, \n                 { \n                     \"Name\" :   \"deadline\" , \n                     \"DataType\" :   \"date\" , \n                     \"ColumnType\" :   \"date\" , \n                     \"IsNullable\" :   true \n                 }, \n                 { \n                     \"Name\" :   \"order\" , \n                     \"ColumnName\" :   \"item_order\" , \n                     \"DataType\" :   \"int(4)\" , \n                     \"ColumnType\" :   \"measurement\" , \n                     \"DefaultValue\" :   \"10\" \n                 }, \n                 { \n                     \"Name\" :   \"text\" , \n                     \"DataType\" :   \"text\" , \n                     \"ColumnType\" :   \"content\" , \n                     \"IsNullable\" :   true \n                 } \n             ], \n             \"Conformations\" :   [{ \n                 \"ColumnName\" :   \"order\" , \n                 \"Tags\" :   \"numeric\" \n             }], \n             \"validations\" :   [{ \n                 \"ColumnName\" :   \"title\" , \n                 \"Tags\" :   \"required\" \n             }]  ] }    Name: Name is a human readable name  Column Name: Name of the column in the table  Column Type: The type of the column. Daptin supports a variety of types and these allow daptin to give you useful options in future (eg for viewing a timeline, a date/datetime column is required)  Default value: Columns can have default values, which is used a new row is created and no value for that column is specified.   While the same description in YAML will look as follows  Tables :  -   TableName :   todo \n   Columns : \n   -   Name :   title \n     DataType :   varchar(500) \n     ColumnType :   label \n     IsIndexed :   true \n   -   Name :   url \n     DataType :   varchar(200) \n     ColumnType :   url \n     IsNullable :   true \n   -   Name :   completed \n     DataType :   int(1) \n     ColumnType :   truefalse \n     DefaultValue :   'false' \n   -   Name :   schedule \n     DataType :   date \n     ColumnType :   date \n     IsNullable :   true \n   -   Name :   order \n     ColumnName :   item_order \n     DataType :   int(4) \n     ColumnType :   measurement \n     DefaultValue :   '10' \n   -   Name :   text \n     DataType :   text \n     ColumnType :   content \n     IsNullable :   true \n   Conformations : \n   -   ColumnName :   order \n     Tags :   numeric \n   Validations : \n   -   ColumnName :   title  Tags :   required   You can choose to work with either json or yaml. Once the schema is ready, it can be uploaded directly from daptin dashboard.",
            "title": "JSON / YAML files"
        },
        {
            "location": "/setting-up/entities/#column-specifications",
            "text": "Columns of the entity can be cusomised:     Property Name  Property Type  Description      Name  string  human readable name, can be skipped    ColumnName  string  column name in the table    ColumnDescription  string  human readable description    ColumnType  string  column type is a rich type of the column    IsIndexed  boolean  true to add an index on this column    IsUnique  boolean  true to set a unique constraint on this column    IsNullable  boolean  are null values allowed    Permission  uint64  permission column (check authorization docs)    DataType  string  the column type inside the database    DefaultValue  string  default value if any (has to be inside single quotes for static values",
            "title": "Column specifications"
        },
        {
            "location": "/setting-up/entities/#column-types",
            "text": "Daptin supports a variety of rich data types, which helps it to automatically make intelligent decisions and validations. Here is a list of all column types and what should they be used for     Type Name  Description  Example      id  an identity column, mostly for internal purposes  1    alias  a foreign key column  uuid v4    date  full date, no time  2017-12-30    time  time/time interval, no date  12:34:54    day  day of the month  1 to 31    month  month of the year  1 to 12    year  Year  2017    minute  minute of the hour  0 to 59    hour  hour of the dat  0 - 23    datetime  date + time (not stored as timestamp, served at date time string)  2017-12-30T12:34:54    email  email  test@domain.com    name  column to be used as name of the entity  daptin    json  JSON data  {}    password  password - are bcrypted with cost 11  $2a$11$z/VlxycDgZ...    value  value is enumeration type  completed    truefalse  boolean  1    timestamp  timestamp (stored as timestamp, served as timestamp)  123123123    location.latitude  only latitude  34.2938    location  latitude + longitude in geoJson format  [34.223,64.123]    location.longitude  only longitude  64.123    location.altitude  only altitude  34    color  hex color string  #ABCDE1    rating.10  rating on a scale of 10  8    measurement  numeric column  534    label  a label for the entity, similar to name but can be more than one  red    content  larger contents - texts/html/json/yaml  very long text    file  uploads, connect storage for using this     url  Urls/links  http://docs.dapt.in",
            "title": "Column types"
        },
        {
            "location": "/setting-up/entities/#excel-file-upload",
            "text": "Excel upload provides an easy way to create entities. This takes away the complexity of writing each column type. Daptin uses a combination of rules to identify columns and their types based on the data in the excel.  You can upload data from XLS. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.",
            "title": "Excel file upload"
        },
        {
            "location": "/setting-up/entities/#restart",
            "text": "Daptin relies on self restarts to configure new entities and apis. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.  You can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.",
            "title": "Restart"
        },
        {
            "location": "/setting-up/entity_relations/",
            "text": "Entity relations\n\n\nA data oriented system with no relational knowledge of the data is next to an Excel sheet. Specifying relations in your data is the most important thing after creating your entities.\n\n\nRelations in JSON/YAML schema\n\n\nWhen uploading schema using a JSON / YAML file, relations can be added in the same file and daptin will create appropriate constraints and foreign keys in your underlying database.\n\n\nContinuing with our example of todos, lets say we want to group todo's in \"projects\" and each todo can belong to only a single project.\n\n\nLets design a \"project\" entity:\n\n\n-\n \nTableName\n:\n \nproject\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \nname\n\n    \nDataType\n:\n \nvarchar(200)\n\n    \nColumnType\n:\n \nname\n\n    \nIsIndexed\n:\n \ntrue\n\n\n\n\n\nA very simple table with just a name column. Now we can tell daptin about the relation between todos and projects\n\n\nRelations\n:\n\n\n-\n \nSubject\n:\n \ntodo\n\n  \nRelation\n:\n \nhas_one\n\n  \nObject\n:\n \nproject\n\n\n\n\n\nThis tells daptin that todo \"has_one\" project.\n\n\nRelations types\n\n\nAny entity can be associated to any other entity (or to itself) as one of the follows\n\n\n\n\n\n\n\n\nRelation Name\n\n\nRelation Descriptio\n\n\nCan be empty\n\n\n\n\n\n\n\n\n\n\nbelongs_to\n\n\na single object relation\n\n\nNo\n\n\n\n\n\n\nhas_one\n\n\na single object relation\n\n\nYes\n\n\n\n\n\n\nhas_many\n\n\nmany related objects\n\n\nYes\n\n\n\n\n\n\n\n\nDefault relations\n\n\nEvery entity created on daptin has at least two relations\n\n\n\n\n\n\n\n\nRelation Type\n\n\nRelated Entity\n\n\n\n\n\n\n\n\n\n\nbelongs\n\n\nuser\n\n\n\n\n\n\nhas many\n\n\nusergroup\n\n\n\n\n\n\n\n\nTo understand why these two relations will always exist, checkout \ndaptin authorization model\n\n\nMultiple relation\n\n\nThere can be a scenario where two entities are related in more then 1 way. Consider the following example\n\n\n\n\nA blog entity\n\n\nA post entity\n\n\nBlog has many posts\n\n\nEach blog can have a \"highlighted post\" (blog has one \"highlighted post\")\n\n\n\n\nTo achieve the above scenario, our schema would look like as follows\n\n\nTables\n:\n\n\n-\n \nTableName\n:\n \nblog\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(500)\n\n    \nColumnType\n:\n \nlabel\n\n  \n-\n \nName\n:\n \nview_count\n\n    \nDataType\n:\n \nint(11)\n\n    \nColumnType\n:\n \nmeasurement\n\n\n-\n \nTableName\n:\n \npost\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(200)\n\n    \nColumnType\n:\n \nlabel\n\n  \n-\n \nName\n:\n \nbody\n\n    \nDataType\n:\n \ntext\n\n    \nColumnType\n:\n \ncontent\n\n\n-\n \nTableName\n:\n \ncomment\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \nbody\n\n    \nDataType\n:\n \ntext\n\n    \nColumnType\n:\n \ncontent\n\n  \n-\n \nName\n:\n \nlikes_count\n\n    \nColumnName\n:\n \nlikes_count\n\n    \nDataType\n:\n \nint(11)\n\n    \nColumnType\n:\n \nmeasurement\n\n\nRelations\n:\n\n\n-\n \nSubject\n:\n \ncomment\n\n  \nRelation\n:\n \nbelongs_to\n\n  \nObject\n:\n \npost\n\n\n-\n \nSubject\n:\n \npost\n\n  \nRelation\n:\n \nbelongs_to\n\n  \nObject\n:\n \nblog                   // this is our post belongs to blog relation\n\n\n-\n \nSubject\n:\n \nblog\n\n  \nRelation\n:\n \nhas_one\n\n  \nObject\n:\n \npost\n\n  \nObjectName\n:\n \ncurrent_post\n\n  \nSubjectName\n:\n \ncurrent_post_of   // this is our highlighted post relation\n\n\n\n\n\nNotice the \"SubjectName\" and \"ObjectName\" keys which helps to name our relations more intuitively.\n\n\nSQL constraints\n\n\nbelongs to\n\n\n\n\nA column is added to the subject entity, which refers to the Object entity, set to non nullable\n\n\n\n\nhas one\n\n\n\n\nSame as above, but nullable\n\n\n\n\nhas many\n\n\n\n\nA join table is created",
            "title": "Entity relations"
        },
        {
            "location": "/setting-up/entity_relations/#entity-relations",
            "text": "A data oriented system with no relational knowledge of the data is next to an Excel sheet. Specifying relations in your data is the most important thing after creating your entities.",
            "title": "Entity relations"
        },
        {
            "location": "/setting-up/entity_relations/#relations-in-jsonyaml-schema",
            "text": "When uploading schema using a JSON / YAML file, relations can be added in the same file and daptin will create appropriate constraints and foreign keys in your underlying database.  Continuing with our example of todos, lets say we want to group todo's in \"projects\" and each todo can belong to only a single project.  Lets design a \"project\" entity:  -   TableName :   project \n   Columns : \n   -   Name :   name \n     DataType :   varchar(200) \n     ColumnType :   name \n     IsIndexed :   true   A very simple table with just a name column. Now we can tell daptin about the relation between todos and projects  Relations :  -   Subject :   todo \n   Relation :   has_one \n   Object :   project   This tells daptin that todo \"has_one\" project.",
            "title": "Relations in JSON/YAML schema"
        },
        {
            "location": "/setting-up/entity_relations/#relations-types",
            "text": "Any entity can be associated to any other entity (or to itself) as one of the follows     Relation Name  Relation Descriptio  Can be empty      belongs_to  a single object relation  No    has_one  a single object relation  Yes    has_many  many related objects  Yes",
            "title": "Relations types"
        },
        {
            "location": "/setting-up/entity_relations/#default-relations",
            "text": "Every entity created on daptin has at least two relations     Relation Type  Related Entity      belongs  user    has many  usergroup     To understand why these two relations will always exist, checkout  daptin authorization model",
            "title": "Default relations"
        },
        {
            "location": "/setting-up/entity_relations/#multiple-relation",
            "text": "There can be a scenario where two entities are related in more then 1 way. Consider the following example   A blog entity  A post entity  Blog has many posts  Each blog can have a \"highlighted post\" (blog has one \"highlighted post\")   To achieve the above scenario, our schema would look like as follows  Tables :  -   TableName :   blog \n   Columns : \n   -   Name :   title \n     DataType :   varchar(500) \n     ColumnType :   label \n   -   Name :   view_count \n     DataType :   int(11) \n     ColumnType :   measurement  -   TableName :   post \n   Columns : \n   -   Name :   title \n     DataType :   varchar(200) \n     ColumnType :   label \n   -   Name :   body \n     DataType :   text \n     ColumnType :   content  -   TableName :   comment \n   Columns : \n   -   Name :   body \n     DataType :   text \n     ColumnType :   content \n   -   Name :   likes_count \n     ColumnName :   likes_count \n     DataType :   int(11) \n     ColumnType :   measurement  Relations :  -   Subject :   comment \n   Relation :   belongs_to \n   Object :   post  -   Subject :   post \n   Relation :   belongs_to \n   Object :   blog                   // this is our post belongs to blog relation  -   Subject :   blog \n   Relation :   has_one \n   Object :   post \n   ObjectName :   current_post \n   SubjectName :   current_post_of   // this is our highlighted post relation   Notice the \"SubjectName\" and \"ObjectName\" keys which helps to name our relations more intuitively.",
            "title": "Multiple relation"
        },
        {
            "location": "/setting-up/entity_relations/#sql-constraints",
            "text": "",
            "title": "SQL constraints"
        },
        {
            "location": "/setting-up/entity_relations/#belongs-to",
            "text": "A column is added to the subject entity, which refers to the Object entity, set to non nullable",
            "title": "belongs to"
        },
        {
            "location": "/setting-up/entity_relations/#has-one",
            "text": "Same as above, but nullable",
            "title": "has one"
        },
        {
            "location": "/setting-up/entity_relations/#has-many",
            "text": "A join table is created",
            "title": "has many"
        },
        {
            "location": "/data-modeling/data_storage/",
            "text": "Data storage\n\n\nDaptin relies on a relational database for all data persistence requirements. As covered in the \nsetting up guide\n currently the following relational database are supported:\n\n\n\n\nMySQL\n\n\nPostgreSQL\n\n\nSQLite\n\n\n\n\nThis document goes into the detail of how the database is used and what are the tables created.\n\n\nStandard columns\n\n\nThe following 5 columns are present in every table\n\n\n\n\n\n\n\n\nColumnName\n\n\nColumnType\n\n\nDataType\n\n\nAttributes\n\n\n\n\n\n\n\n\n\n\nid\n\n\nid\n\n\nint(11)\n\n\nprimary key  Auto increment Never exposed externally\n\n\n\n\n\n\nversion\n\n\ninteger\n\n\nint(11)\n\n\nget incremented every time a change is made\n\n\n\n\n\n\ncreated_at\n\n\ntimestamp\n\n\ntimestamp\n\n\nthe timestamp when the row was created\n\n\n\n\n\n\nupdated_at\n\n\ntimestamp\n\n\ntimestamp\n\n\nthe timestamp when the row was last updated\n\n\n\n\n\n\nreference_id\n\n\nalias\n\n\nvarchar(40)\n\n\nThe id exposed in APIs\n\n\n\n\n\n\npermission\n\n\ninteger\n\n\nint(4)\n\n\nPermissions - check Authorization documentation\n\n\n\n\n\n\nuser_id\n\n\nforeign key\n\n\nint(11)\n\n\nthe owner of this object\n\n\n\n\n\n\n\n\nOther columns are created based on the schema. \n\n\nThe \nid\n column is completely for internal purposes and is never exposed in an JSON API.\nEvery row of data inherently belongs to one user. This is the user who created that row. The associated user can be changed later.\n\n\nWorld table\n\n\nThe \nworld\n table holds the structure for all the entities and relations (including for itself).\n\n\nEach row contains the schema for the table in a \"world_schema_json\" column.",
            "title": "Data storage"
        },
        {
            "location": "/data-modeling/data_storage/#data-storage",
            "text": "Daptin relies on a relational database for all data persistence requirements. As covered in the  setting up guide  currently the following relational database are supported:   MySQL  PostgreSQL  SQLite   This document goes into the detail of how the database is used and what are the tables created.",
            "title": "Data storage"
        },
        {
            "location": "/data-modeling/data_storage/#standard-columns",
            "text": "The following 5 columns are present in every table     ColumnName  ColumnType  DataType  Attributes      id  id  int(11)  primary key  Auto increment Never exposed externally    version  integer  int(11)  get incremented every time a change is made    created_at  timestamp  timestamp  the timestamp when the row was created    updated_at  timestamp  timestamp  the timestamp when the row was last updated    reference_id  alias  varchar(40)  The id exposed in APIs    permission  integer  int(4)  Permissions - check Authorization documentation    user_id  foreign key  int(11)  the owner of this object     Other columns are created based on the schema.   The  id  column is completely for internal purposes and is never exposed in an JSON API.\nEvery row of data inherently belongs to one user. This is the user who created that row. The associated user can be changed later.",
            "title": "Standard columns"
        },
        {
            "location": "/data-modeling/data_storage/#world-table",
            "text": "The  world  table holds the structure for all the entities and relations (including for itself).  Each row contains the schema for the table in a \"world_schema_json\" column.",
            "title": "World table"
        },
        {
            "location": "/cloudstore/cloudstore/",
            "text": "Cloud store\n\n\nDatin can work with the following storage services:\n\n\n\n\nAmazon Drive  \n\n\nAmazon S3  \n\n\nBackblaze B2  \n\n\nBox  \n\n\nCeph  \n\n\nDigitalOcean Spaces  \n\n\nDreamhost  \n\n\nDropbox  \n\n\nFTP  \n\n\nGoogle Cloud Storage  \n\n\nGoogle Drive  \n\n\nHTTP  \n\n\nHubic  \n\n\nMemset Memstore  \n\n\nMicrosoft Azure Blob Storage  \n\n\nMicrosoft OneDrive  \n\n\nMinio  \n\n\nNextloud  \n\n\nOVH  \n\n\nOpenstack Swift  \n\n\nOracle Cloud Storage  \n\n\nOwnloud  \n\n\npCloud  \n\n\nput.io  \n\n\nQingStor  \n\n\nRackspace Cloud Files  \n\n\nSFTP  \n\n\nWasabi  \n\n\nWebDAV  \n\n\nYandex Disk  \n\n\nThe local filesystem  \n\n\n\n\nCreating a new cloud storage instance\n\n\nThing to keep ready\n\n\nIf the service you wan to integrate with requires authentication, create the following:\n\n\n\n\nAn \noauth connection\n\n\nAn \noauth token\n generated from the above connection\n\n\n\n\nSteps\n\n\n\n\nLogin to the dashboard\n\n\nClick \"Storage\" tile\n\n\nClick the green \"+\" icon on the top right\n\n\nUse the \nname\n to identify it uniquely\n\n\nRoot Path\n: in rclone format, eg\n\n\ngdrive: \ndrive:directory/subdirectory\n\n\ndropbox/ftp/local: \nremote/local:directory/subdirectory\n\n\nStore Provider\n: dropbox/drive/local/ftp...\n\n\nStore Type\n: cloud/local",
            "title": "Cloud storage"
        },
        {
            "location": "/cloudstore/cloudstore/#cloud-store",
            "text": "Datin can work with the following storage services:   Amazon Drive    Amazon S3    Backblaze B2    Box    Ceph    DigitalOcean Spaces    Dreamhost    Dropbox    FTP    Google Cloud Storage    Google Drive    HTTP    Hubic    Memset Memstore    Microsoft Azure Blob Storage    Microsoft OneDrive    Minio    Nextloud    OVH    Openstack Swift    Oracle Cloud Storage    Ownloud    pCloud    put.io    QingStor    Rackspace Cloud Files    SFTP    Wasabi    WebDAV    Yandex Disk    The local filesystem",
            "title": "Cloud store"
        },
        {
            "location": "/cloudstore/cloudstore/#creating-a-new-cloud-storage-instance",
            "text": "",
            "title": "Creating a new cloud storage instance"
        },
        {
            "location": "/cloudstore/cloudstore/#thing-to-keep-ready",
            "text": "If the service you wan to integrate with requires authentication, create the following:   An  oauth connection  An  oauth token  generated from the above connection",
            "title": "Thing to keep ready"
        },
        {
            "location": "/cloudstore/cloudstore/#steps",
            "text": "Login to the dashboard  Click \"Storage\" tile  Click the green \"+\" icon on the top right  Use the  name  to identify it uniquely  Root Path : in rclone format, eg  gdrive:  drive:directory/subdirectory  dropbox/ftp/local:  remote/local:directory/subdirectory  Store Provider : dropbox/drive/local/ftp...  Store Type : cloud/local",
            "title": "Steps"
        },
        {
            "location": "/subsite/subsite/",
            "text": "Sub site\n\n\nYou can host multiple sites using daptin. A sub site is exposing a cloud storage folder statically under a sub-domain, domain or a path. \n\n\nCreating a new sub-site\n\n\n\n\nGoto dashboard https://dashboard.domain.com/\n\n\nClick \"Sub sites\"\n\n\nClick the green \"+\" icon\n\n\nType in the \nhostname\n this should be exposed to\n\n\nthis can be a domain or a sub-domain\n\n\nthe domain should be pointing to the daptin instance\n\n\nChoose a \nname\n\n\nPath\n: select a sub directory name to expose this sub-site. Your sub-site will be accessible at domain.com/\n\n\nCloud store Id\n: choose an existing \ncloud store\n.\n\n\n\n\nRestart to enable serving the site. \n\n\nDaptin will sync the cloud store locally and start serving it under the domain/path.",
            "title": "Subsites"
        },
        {
            "location": "/subsite/subsite/#sub-site",
            "text": "You can host multiple sites using daptin. A sub site is exposing a cloud storage folder statically under a sub-domain, domain or a path.",
            "title": "Sub site"
        },
        {
            "location": "/subsite/subsite/#creating-a-new-sub-site",
            "text": "Goto dashboard https://dashboard.domain.com/  Click \"Sub sites\"  Click the green \"+\" icon  Type in the  hostname  this should be exposed to  this can be a domain or a sub-domain  the domain should be pointing to the daptin instance  Choose a  name  Path : select a sub directory name to expose this sub-site. Your sub-site will be accessible at domain.com/  Cloud store Id : choose an existing  cloud store .   Restart to enable serving the site.   Daptin will sync the cloud store locally and start serving it under the domain/path.",
            "title": "Creating a new sub-site"
        },
        {
            "location": "/auth/users_and_usergroups/",
            "text": "User Management\n\n\nDaptin natively manages users and usergroups so that it has no dependency on external user management services. Though it can be integrated with such services.\n\n\nUsers\n\n\nUsers are native objects in Daptin. Every item in daptin belongs to one user. A user which is not identified is a guest user. User identification is based on the JWT token in the \nAuthorization\n header\n\n\nBy default each user has one usergroup. A user can belong more user groups.\n\n\nUser groups\n\n\nUser groups is a group concept that helps you manage \"who\" can interact with daptin, and in what ways.\n\n\nUsers and Objects belong to one or more user group.",
            "title": "Users and groups"
        },
        {
            "location": "/auth/users_and_usergroups/#user-management",
            "text": "Daptin natively manages users and usergroups so that it has no dependency on external user management services. Though it can be integrated with such services.",
            "title": "User Management"
        },
        {
            "location": "/auth/users_and_usergroups/#users",
            "text": "Users are native objects in Daptin. Every item in daptin belongs to one user. A user which is not identified is a guest user. User identification is based on the JWT token in the  Authorization  header  By default each user has one usergroup. A user can belong more user groups.",
            "title": "Users"
        },
        {
            "location": "/auth/users_and_usergroups/#user-groups",
            "text": "User groups is a group concept that helps you manage \"who\" can interact with daptin, and in what ways.  Users and Objects belong to one or more user group.",
            "title": "User groups"
        },
        {
            "location": "/auth/authorization/",
            "text": "Access Authorization\n\n\nAuthorization is the part where daptin decides if the caller has enough permission to execute the call. Currently daptin has the following permissions.\n\n\nEntity level permission check\n\n\nThe world table has the list of all entities. Consider the scenario where we created a todo list. The world table would have a row to represent this entity\n\n\n\n\n\n\n\n\nEntity\n\n\nPermission\n\n\n\n\n\n\n\n\n\n\ntodo\n\n\n112000006\n\n\n\n\n\n\n\n\nHere:\n\n\n\n\n112 is for owners, which basically means 64 + 32 + 16 = Refer/Execute/Delete\n\n\n000 is for group users, no permission allowed in this case\n\n\n006 is for guest users, which is 2 + 4 = Read/Create\n\n\n\n\nObject level permission check\n\n\nOnce the call clears the entity level check, an object level permission check is applied. This happens in cases where the action is going to affect/read an existing row. The permission is stored in the same way. Each table has a permission column which stores the permission in \nOOOGGGXXX\n format.\n\n\nOrder of permission check\n\n\nThe permission is checked in order of:\n\n\n\n\nCheck if the user is owner, if yes, check if permission allows the current action, if yes do action\n\n\nCheck if the user belongs to a group to which this object also belongs, if yes, check if permisison allows the current action, if yes do action\n\n\nUser is guest, check if guest permission allows this actions, if yes do action, if no, unauthorized\n\n\n\n\nThings to note here:\n\n\n\n\nThere is no negative permission (this may be introduced in the future)\n\n\neg, you cannot say owner is 'not allowed' to read but read by guest is allowed. \n\n\nPermission check is done in a hierarchy type order\n\n\n\n\nAccess flow\n\n\nEvery \"interaction\" in daptin goes through two levels of access. Each level has a \nbefore\n and \nafter\n check.\n\n\n\n\nEntity level access: does the user invoking the interaction has the appropriate permission to invoke this (So for sign up, the user table need to be writable by guests, for sign in the user table needs to be peakable by guests)\n\n\nInstance level access: this is the second level, even if a user has access to \"user\" entity, not all \"user\" rows would be accessible by them\n\n\n\n\nSo the actual checks happen in following order:\n\n\n\n\n\"Before check\" for entity\n\n\n\"Before check\" for instance\n\n\n\"After check\" for instance\n\n\n\"After check\" for entity\n\n\n\n\nEach of these checks can filter out objects where the user does not have enough permission.\n\n\nEntity level permission\n\n\nEntity level permission are set in the world table and can be updated from dashboard. This can be done by updating the \"permission\" column for the entity.\n\n\nFor these changes to take effect a restart is necessary.\n\n\nInstance level permission\n\n\nLike we saw in the \nentity documentation\n, every table has a \npermission\n column. No restart is necessary for changes in these permission.\n\n\nPermission column\n\n\nThe permission column contains a nine digit number, which decides the access for guests (the world), user groups and owner\n\n\nThe nine digits can be represented as follows:\n\n\nUUUGGGWWW\n\n\nEach entity has a permission field which is added by daptin. The permission field is a 9 digit number, in the following format\n\n\nThe first three digits(UUU) represent the permission for the owner.\nThe next three digits(GGG) represent the permission for the group.\nThe last three digits(WWW)  represent the permission for guest users.\n\n\nU = User\nG = Group\nW = World\n\n\n\n\nPeek - 1\n\n\nRead - 2\n\n\nCreate - 4\n\n\nUpdate - 8\n\n\nDelete - 16\n\n\nExecute - 32\n\n\nRefer - 64\n\n\n\n\nHere is another way of looking at it:\n\n\nPermissions:\n\n\n002,000,000 read by owner\n000,020,000 read by group\n000,000,002 read by anybody (other)\n004,000,000 write by owner\n000,004,000 write by group\n000,000,004 write by anybody\n032,000,000 execute by owner\n000,032,000 execute by group\n000,000,032 execute by anybody\n\n\nTo get a combination, just add them up.\n\n\nFor example, to get\n\n\n\n\nread, write, execute by owner\n\n\nread, execute, by group\n\n\nexecute by anybody\n\n\n\n\nyou would add (002 + 004 + 032),(002 + 032),(032) to give 038034032.",
            "title": "Authorization"
        },
        {
            "location": "/auth/authorization/#access-authorization",
            "text": "Authorization is the part where daptin decides if the caller has enough permission to execute the call. Currently daptin has the following permissions.",
            "title": "Access Authorization"
        },
        {
            "location": "/auth/authorization/#entity-level-permission-check",
            "text": "The world table has the list of all entities. Consider the scenario where we created a todo list. The world table would have a row to represent this entity     Entity  Permission      todo  112000006     Here:   112 is for owners, which basically means 64 + 32 + 16 = Refer/Execute/Delete  000 is for group users, no permission allowed in this case  006 is for guest users, which is 2 + 4 = Read/Create",
            "title": "Entity level permission check"
        },
        {
            "location": "/auth/authorization/#object-level-permission-check",
            "text": "Once the call clears the entity level check, an object level permission check is applied. This happens in cases where the action is going to affect/read an existing row. The permission is stored in the same way. Each table has a permission column which stores the permission in  OOOGGGXXX  format.",
            "title": "Object level permission check"
        },
        {
            "location": "/auth/authorization/#order-of-permission-check",
            "text": "The permission is checked in order of:   Check if the user is owner, if yes, check if permission allows the current action, if yes do action  Check if the user belongs to a group to which this object also belongs, if yes, check if permisison allows the current action, if yes do action  User is guest, check if guest permission allows this actions, if yes do action, if no, unauthorized   Things to note here:   There is no negative permission (this may be introduced in the future)  eg, you cannot say owner is 'not allowed' to read but read by guest is allowed.   Permission check is done in a hierarchy type order",
            "title": "Order of permission check"
        },
        {
            "location": "/auth/authorization/#access-flow",
            "text": "Every \"interaction\" in daptin goes through two levels of access. Each level has a  before  and  after  check.   Entity level access: does the user invoking the interaction has the appropriate permission to invoke this (So for sign up, the user table need to be writable by guests, for sign in the user table needs to be peakable by guests)  Instance level access: this is the second level, even if a user has access to \"user\" entity, not all \"user\" rows would be accessible by them   So the actual checks happen in following order:   \"Before check\" for entity  \"Before check\" for instance  \"After check\" for instance  \"After check\" for entity   Each of these checks can filter out objects where the user does not have enough permission.",
            "title": "Access flow"
        },
        {
            "location": "/auth/authorization/#entity-level-permission",
            "text": "Entity level permission are set in the world table and can be updated from dashboard. This can be done by updating the \"permission\" column for the entity.  For these changes to take effect a restart is necessary.",
            "title": "Entity level permission"
        },
        {
            "location": "/auth/authorization/#instance-level-permission",
            "text": "Like we saw in the  entity documentation , every table has a  permission  column. No restart is necessary for changes in these permission.",
            "title": "Instance level permission"
        },
        {
            "location": "/auth/authorization/#permission-column",
            "text": "The permission column contains a nine digit number, which decides the access for guests (the world), user groups and owner  The nine digits can be represented as follows:  UUUGGGWWW  Each entity has a permission field which is added by daptin. The permission field is a 9 digit number, in the following format  The first three digits(UUU) represent the permission for the owner.\nThe next three digits(GGG) represent the permission for the group.\nThe last three digits(WWW)  represent the permission for guest users.  U = User\nG = Group\nW = World   Peek - 1  Read - 2  Create - 4  Update - 8  Delete - 16  Execute - 32  Refer - 64   Here is another way of looking at it:  Permissions:  002,000,000 read by owner\n000,020,000 read by group\n000,000,002 read by anybody (other)\n004,000,000 write by owner\n000,004,000 write by group\n000,000,004 write by anybody\n032,000,000 execute by owner\n000,032,000 execute by group\n000,000,032 execute by anybody  To get a combination, just add them up.  For example, to get   read, write, execute by owner  read, execute, by group  execute by anybody   you would add (002 + 004 + 032),(002 + 032),(032) to give 038034032.",
            "title": "Permission column"
        },
        {
            "location": "/auth/authentication/",
            "text": "Authentication\n\n\nDaptin maintains its own user accounts and usergroups as well. Users are identified by \nemail\n which is a unique key in the \nuser\n entity. Passwords are stored using bcrypt with a cost of 11. Password field has a column_type \npassword\n which makes daptin to bcrypt it before storing, and password fields are never returned in any JSONAPI call.\n\n\nAuthentication token\n\n\nThe authentication token is a JWT token issued by daptin on sign in action. Users can create new actions to allow other means of generating JWT token. It is as simple as adding another outcome to an action.\n\n\nServer side\n\n\nDaptin uses oAuth2 based authentication strategy. HTTP calls are checked for \nAuthorization\n header, and if present, validates the token as a JWT token.\n\n\nThe JWT token contains the issuer info (Daptin in this case) plus basic user profile (email). The JWT token has a one hour expiry from the time of issue.\n\n\nIf the token is absent or invalid, the user is considered as a guest. Guests also have certain permissions. Checkout the \nAuthorization docs\n for details. \n\n\nClient side\n\n\nOn the client side, for dashboard, the token is stored in local storage. The local storage is cleared on logout or if the server responds with a 401 Unauthorized status.\n\n\nAuthentication using other systems\n\n\nThere is planned road map to allow user logins via external oauth2 servers as well (login via google/facebook/twitter... and so on). This feature is not complete yet. Documentation will be updated to reflect changes.\n\n\nSign Up\n\n\nSign up is an action on user entity. Sign up takes four inputs:\n\n\n\n\nName\n\n\nEmail\n\n\nPassword\n\n\nPasswordConfirm\n\n\n\n\nWhen the user initates a Sign up action, the following things happen\n\n\n\n\nCheck if guests can initiate sign in action\n\n\nCheck if guests can create a new user (create permission)\n\n\nCreate a new user row\n\n\nCheck if guests can create a new usergroup (create permission)\n\n\nCreate a new usergroup row\n\n\nAssociate the user to the usergroup (refer permission)\n\n\n\n\nThis means that every user has his own dedicated usergrou by default. \n\n\nSign In\n\n\nSign In is also an action on user entity. Sign in takes two inputs:\n\n\n\n\nEmail\n\n\nPassword\n\n\n\n\nWhen the user initiates Sign in action, the following things happen:\n\n\n\n\nCheck if guests can peek users table (Peek permission)\n\n\nCheck if guests can peek the particular user (Peek Permission)\n\n\nMatch if the provided password bcrypted matches the stored bcrypted password\n\n\nIf true, issue a JWT token, which is used for future calls\n\n\n\n\nThe main outcome of the Sign In action is the jwt token, which is to be used in the \nAuthorization\n header of following calls.",
            "title": "Authentication"
        },
        {
            "location": "/auth/authentication/#authentication",
            "text": "Daptin maintains its own user accounts and usergroups as well. Users are identified by  email  which is a unique key in the  user  entity. Passwords are stored using bcrypt with a cost of 11. Password field has a column_type  password  which makes daptin to bcrypt it before storing, and password fields are never returned in any JSONAPI call.",
            "title": "Authentication"
        },
        {
            "location": "/auth/authentication/#authentication-token",
            "text": "The authentication token is a JWT token issued by daptin on sign in action. Users can create new actions to allow other means of generating JWT token. It is as simple as adding another outcome to an action.",
            "title": "Authentication token"
        },
        {
            "location": "/auth/authentication/#server-side",
            "text": "Daptin uses oAuth2 based authentication strategy. HTTP calls are checked for  Authorization  header, and if present, validates the token as a JWT token.  The JWT token contains the issuer info (Daptin in this case) plus basic user profile (email). The JWT token has a one hour expiry from the time of issue.  If the token is absent or invalid, the user is considered as a guest. Guests also have certain permissions. Checkout the  Authorization docs  for details.",
            "title": "Server side"
        },
        {
            "location": "/auth/authentication/#client-side",
            "text": "On the client side, for dashboard, the token is stored in local storage. The local storage is cleared on logout or if the server responds with a 401 Unauthorized status.",
            "title": "Client side"
        },
        {
            "location": "/auth/authentication/#authentication-using-other-systems",
            "text": "There is planned road map to allow user logins via external oauth2 servers as well (login via google/facebook/twitter... and so on). This feature is not complete yet. Documentation will be updated to reflect changes.",
            "title": "Authentication using other systems"
        },
        {
            "location": "/auth/authentication/#sign-up",
            "text": "Sign up is an action on user entity. Sign up takes four inputs:   Name  Email  Password  PasswordConfirm   When the user initates a Sign up action, the following things happen   Check if guests can initiate sign in action  Check if guests can create a new user (create permission)  Create a new user row  Check if guests can create a new usergroup (create permission)  Create a new usergroup row  Associate the user to the usergroup (refer permission)   This means that every user has his own dedicated usergrou by default.",
            "title": "Sign Up"
        },
        {
            "location": "/auth/authentication/#sign-in",
            "text": "Sign In is also an action on user entity. Sign in takes two inputs:   Email  Password   When the user initiates Sign in action, the following things happen:   Check if guests can peek users table (Peek permission)  Check if guests can peek the particular user (Peek Permission)  Match if the provided password bcrypted matches the stored bcrypted password  If true, issue a JWT token, which is used for future calls   The main outcome of the Sign In action is the jwt token, which is to be used in the  Authorization  header of following calls.",
            "title": "Sign In"
        },
        {
            "location": "/actions-streams/actions/",
            "text": "Actions\n\n\nActions are the most useful things in Daptin and we will see that everything you have done in Daptin was as action itself.\n\n\nActions can be thought of as follows:\n\n\n\n\nA set of inputs\n\n\nA set of outcomes based on the inputs\n\n\n\n\nWhat are actions and why do I need this\n\n\nCreate/Read/Update/Delete (CRUD) APIs are only the most basic apis exposed on the database, and you would rarely want to make those API available to your end user. Reasons could be multiple\n\n\n\n\nThe end user doesn't (immediately) owe the data they create\n\n\nCreating a \"row\"/\"data entry\" entry doesnt signify completion of a process or a flow\n\n\nUsually a \"set of entities\" is to created and not just a single entity (when you create a user, you also want to create a usergroup also and associate the user to usergroup)\n\n\nYou could allow user to update only some fields of an entity and not all fields (eg user can change their name, but not email)\n\n\nChanges based on some entity (when you are going though a project, a new todo should automatically belong to that project)\n\n\n\n\nActions provide a powerful abstraction over the CRUD and handle all of these use cases.\n\n\nTo quickly understand what actions are, lets see what happened when you \"signed up\" on Daptin.\n\n\nLets take a look at how \"Sign up\" action is defined in Daptin. We will go through each part of this definition\nAn action is performed on an entity. Lets also remember that \nworld\n is an entity itself.\n\n\nAction schema\n\n\n    {\n        Name:             \"signup\",\n        Label:            \"Sign up\",\n        InstanceOptional: true,\n        OnType:           \"user\",\n        InFields: []api2go.ColumnInfo{\n            {\n                Name:       \"name\",\n                ColumnName: \"name\",\n                ColumnType: \"label\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"email\",\n                ColumnName: \"email\",\n                ColumnType: \"email\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"password\",\n                ColumnName: \"password\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"Password Confirm\",\n                ColumnName: \"passwordConfirm\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n        },\n        Validations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"required\",\n            },\n            {\n                ColumnName: \"password\",\n                Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n            },\n        },\n        Conformations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"trim\",\n            },\n        },\n        OutFields: {\n            {\n                Type:      \"user\",\n                Method:    \"POST\",\n                Reference: \"user\",\n                Attributes: {\n                    \"name\":      \"~name\",\n                    \"email\":     \"~email\",\n                    \"password\":  \"~password\",\n                    \"confirmed\": \"0\",\n                },\n            },\n            {\n                Type:      \"usergroup\",\n                Method:    \"POST\",\n                Reference: \"usergroup\",\n                Attributes: {\n                    \"name\": \"!'Home group for ' + user.name\",\n                },\n            },\n            {\n                Type:      \"user_user_id_has_usergroup_usergroup_id\",\n                Method:    \"POST\",\n                Reference: \"user_usergroup\",\n                Attributes: {\n                    \"user_id\":      \"$user.reference_id\",\n                    \"usergroup_id\": \"$usergroup.reference_id\",\n                },\n            },\n            {\n                Type:   \"client.notify\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"type\":    \"success\",\n                    \"title\":   \"Success\",\n                    \"message\": \"Signup Successful\",\n                },\n            },\n            {\n                Type:   \"client.redirect\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"location\": \"/auth/signin\",\n                    \"window\":   \"self\",\n                },\n            },\n        },\n    }\n\n\n\n\nAction Name\n\n\n    Name:             \"signup\",\n\n\n\n\n\nName of the action, this should be unique for each actions. Actions are identified by this name\n\n\nAction Label\n\n\n    Label:            \"Sign up\",\n\n\n\n\n\nLabel is for humans\n\n\nOnType\n\n\n    OnType:           \"user\",\n\n\n\n\n\nThe primary type of entity on which the action happens. This is used to know where the actions should come up on the UI\n\n\nAction instance\n\n\n    InstanceOptional: true,\n\n\n\n\n\nIf the action requires an \"instance\" of that type on which the action is defined (more about this below). So \"Sign up\" is defined on \"user\" table, but an instance of \"user\" is not required to initiate the action. This is why the \"Sign up\" doesnt ask you to select a user (which wouldn't make sense either)\n\n\nInput fields\n\n\n    InFields: []api2go.ColumnInfo\n\n\n\n\n\nThis is a set of inputs which the user need to fill in to initiate that action. As we see here in case of \"Sign up\", we ask for four inputs\n\n\n\n\nName\n\n\nEmail\n\n\nPassword\n\n\nConfirm password\n\n\n\n\nNote that the ColumnInfo structure is the same one we used to \ndefine tables\n.\n\n\nValidations\n\n\n    Validations: []ColumnTag\n\n\n\n\n\nValidations validate the user input and rejects if some validation fails\n\n\n  {\n            ColumnName: \"email\",\n            Tags:       \"email\",\n        },\n\n\n\n\n\nThis tells that the \"email\" input should actually be an email.\n\n\nOne of the more interesting validations is cross field check\n\n\n        {\n            ColumnName: \"password\",\n            Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n        },\n\n\n\n\n\nThis tells that the value entered by user in the password field should be equal to the value in passwordConfirm field. And the minimum length should be 8 characters.\n\n\nConformations\n\n\n    Conformations: []ColumnTag\n\n\n\n\n\nConformations help to clean the data before the action is carried out. The frequently one used are \ntrim\n and \nemail\n.\n\n\n\n\nTrim: trim removes white spaces, which are sometimes accidently introduced when entering data\n\n\nEmail: email conformation will normalize the email. Things like lowercase + trim\n\n\n\n\nOutFields\n\n\n    OutFields: []Outcome\n\n\n\n\n\nOutFields are the list of outcomes which the action will result in. The outcomes are evaluated in a top to bottom manner, and the result of one outcome is accessible when evaluating the next outcome.\n\n\nWe have defined three outcomes in our \"Sign Up\" action.\n\n\n\n\nCreate a user\n    {\n        Type:      \"user\",\n        Method:    \"POST\",\n        Reference: \"user\",\n        Attributes: map[string]interface{}{\n            \"name\":      \"~name\",\n            \"email\":     \"~email\",\n            \"password\":  \"~password\",\n            \"confirmed\": \"0\",\n        },\n    },\n\n\n\n\n\n\n\n\n\nThis tells us that, the first outcome is of type \"user\". The outcome is a \"New User\" (POST). It could alternatively have been a Update/Find/Delete operation.\n\n\nThe attributes maps the input fields to the fields of our new user.\n\n\n\n\n~name\n will be the value entered by user in the name field\n\n\n~email\n will be the entered in the email field, and so on\n\n\n\n\nIf we skip the \n~\n, like \n\"confirmed\": \"0\"\n Then the literal value is used.\n\n\nReference: \"user\",\n We have this to allow the \"outcome\" to be referenced when evaluating the next outcome. Let us see the other outcomes\n\n\nScripted fields - \"!...\"\n\n\n        {\n            Type:      \"usergroup\",\n            Method:    \"POST\",\n            Reference: \"usergroup\",\n            Attributes: map[string]interface{}{\n                \"name\": \"!'Home group for ' + user.name\",\n            },\n        },\n\n\n\n\n\nDaptin includes the \notto js engine\n. An exclamation mark tell daptin to evaluate the rest of the string as Javascript.\n\n\n'Home group for ' + user.name\n becomes \"Home group for parth\"\n\n\nReferencing previous outcomes\n\n\n        {\n            Type:      \"user_user_id_has_usergroup_usergroup_id\",\n            Method:    \"POST\",\n            Reference: \"user_usergroup\",\n            Attributes: map[string]interface{}{\n                \"user_id\":      \"$user.reference_id\",\n                \"usergroup_id\": \"$usergroup.reference_id\",\n            },\n        },\n\n\n\n\n\nthe \n$\n sign is to refer the previous outcomes. Here this outcome adds the newly created user to the newly created usergroup.",
            "title": "Actions"
        },
        {
            "location": "/actions-streams/actions/#actions",
            "text": "Actions are the most useful things in Daptin and we will see that everything you have done in Daptin was as action itself.  Actions can be thought of as follows:   A set of inputs  A set of outcomes based on the inputs",
            "title": "Actions"
        },
        {
            "location": "/actions-streams/actions/#what-are-actions-and-why-do-i-need-this",
            "text": "Create/Read/Update/Delete (CRUD) APIs are only the most basic apis exposed on the database, and you would rarely want to make those API available to your end user. Reasons could be multiple   The end user doesn't (immediately) owe the data they create  Creating a \"row\"/\"data entry\" entry doesnt signify completion of a process or a flow  Usually a \"set of entities\" is to created and not just a single entity (when you create a user, you also want to create a usergroup also and associate the user to usergroup)  You could allow user to update only some fields of an entity and not all fields (eg user can change their name, but not email)  Changes based on some entity (when you are going though a project, a new todo should automatically belong to that project)   Actions provide a powerful abstraction over the CRUD and handle all of these use cases.  To quickly understand what actions are, lets see what happened when you \"signed up\" on Daptin.  Lets take a look at how \"Sign up\" action is defined in Daptin. We will go through each part of this definition\nAn action is performed on an entity. Lets also remember that  world  is an entity itself.",
            "title": "What are actions and why do I need this"
        },
        {
            "location": "/actions-streams/actions/#action-schema",
            "text": "{\n        Name:             \"signup\",\n        Label:            \"Sign up\",\n        InstanceOptional: true,\n        OnType:           \"user\",\n        InFields: []api2go.ColumnInfo{\n            {\n                Name:       \"name\",\n                ColumnName: \"name\",\n                ColumnType: \"label\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"email\",\n                ColumnName: \"email\",\n                ColumnType: \"email\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"password\",\n                ColumnName: \"password\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"Password Confirm\",\n                ColumnName: \"passwordConfirm\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n        },\n        Validations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"required\",\n            },\n            {\n                ColumnName: \"password\",\n                Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n            },\n        },\n        Conformations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"trim\",\n            },\n        },\n        OutFields: {\n            {\n                Type:      \"user\",\n                Method:    \"POST\",\n                Reference: \"user\",\n                Attributes: {\n                    \"name\":      \"~name\",\n                    \"email\":     \"~email\",\n                    \"password\":  \"~password\",\n                    \"confirmed\": \"0\",\n                },\n            },\n            {\n                Type:      \"usergroup\",\n                Method:    \"POST\",\n                Reference: \"usergroup\",\n                Attributes: {\n                    \"name\": \"!'Home group for ' + user.name\",\n                },\n            },\n            {\n                Type:      \"user_user_id_has_usergroup_usergroup_id\",\n                Method:    \"POST\",\n                Reference: \"user_usergroup\",\n                Attributes: {\n                    \"user_id\":      \"$user.reference_id\",\n                    \"usergroup_id\": \"$usergroup.reference_id\",\n                },\n            },\n            {\n                Type:   \"client.notify\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"type\":    \"success\",\n                    \"title\":   \"Success\",\n                    \"message\": \"Signup Successful\",\n                },\n            },\n            {\n                Type:   \"client.redirect\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"location\": \"/auth/signin\",\n                    \"window\":   \"self\",\n                },\n            },\n        },\n    }",
            "title": "Action schema"
        },
        {
            "location": "/actions-streams/actions/#action-name",
            "text": "Name:             \"signup\",  Name of the action, this should be unique for each actions. Actions are identified by this name",
            "title": "Action Name"
        },
        {
            "location": "/actions-streams/actions/#action-label",
            "text": "Label:            \"Sign up\",  Label is for humans",
            "title": "Action Label"
        },
        {
            "location": "/actions-streams/actions/#ontype",
            "text": "OnType:           \"user\",  The primary type of entity on which the action happens. This is used to know where the actions should come up on the UI",
            "title": "OnType"
        },
        {
            "location": "/actions-streams/actions/#action-instance",
            "text": "InstanceOptional: true,  If the action requires an \"instance\" of that type on which the action is defined (more about this below). So \"Sign up\" is defined on \"user\" table, but an instance of \"user\" is not required to initiate the action. This is why the \"Sign up\" doesnt ask you to select a user (which wouldn't make sense either)",
            "title": "Action instance"
        },
        {
            "location": "/actions-streams/actions/#input-fields",
            "text": "InFields: []api2go.ColumnInfo  This is a set of inputs which the user need to fill in to initiate that action. As we see here in case of \"Sign up\", we ask for four inputs   Name  Email  Password  Confirm password   Note that the ColumnInfo structure is the same one we used to  define tables .",
            "title": "Input fields"
        },
        {
            "location": "/actions-streams/actions/#validations",
            "text": "Validations: []ColumnTag  Validations validate the user input and rejects if some validation fails    {\n            ColumnName: \"email\",\n            Tags:       \"email\",\n        },  This tells that the \"email\" input should actually be an email.  One of the more interesting validations is cross field check          {\n            ColumnName: \"password\",\n            Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n        },  This tells that the value entered by user in the password field should be equal to the value in passwordConfirm field. And the minimum length should be 8 characters.",
            "title": "Validations"
        },
        {
            "location": "/actions-streams/actions/#conformations",
            "text": "Conformations: []ColumnTag  Conformations help to clean the data before the action is carried out. The frequently one used are  trim  and  email .   Trim: trim removes white spaces, which are sometimes accidently introduced when entering data  Email: email conformation will normalize the email. Things like lowercase + trim",
            "title": "Conformations"
        },
        {
            "location": "/actions-streams/actions/#outfields",
            "text": "OutFields: []Outcome  OutFields are the list of outcomes which the action will result in. The outcomes are evaluated in a top to bottom manner, and the result of one outcome is accessible when evaluating the next outcome.  We have defined three outcomes in our \"Sign Up\" action.   Create a user     {\n        Type:      \"user\",\n        Method:    \"POST\",\n        Reference: \"user\",\n        Attributes: map[string]interface{}{\n            \"name\":      \"~name\",\n            \"email\":     \"~email\",\n            \"password\":  \"~password\",\n            \"confirmed\": \"0\",\n        },\n    },    This tells us that, the first outcome is of type \"user\". The outcome is a \"New User\" (POST). It could alternatively have been a Update/Find/Delete operation.  The attributes maps the input fields to the fields of our new user.   ~name  will be the value entered by user in the name field  ~email  will be the entered in the email field, and so on   If we skip the  ~ , like  \"confirmed\": \"0\"  Then the literal value is used.  Reference: \"user\",  We have this to allow the \"outcome\" to be referenced when evaluating the next outcome. Let us see the other outcomes",
            "title": "OutFields"
        },
        {
            "location": "/actions-streams/actions/#scripted-fields-",
            "text": "{\n            Type:      \"usergroup\",\n            Method:    \"POST\",\n            Reference: \"usergroup\",\n            Attributes: map[string]interface{}{\n                \"name\": \"!'Home group for ' + user.name\",\n            },\n        },  Daptin includes the  otto js engine . An exclamation mark tell daptin to evaluate the rest of the string as Javascript.  'Home group for ' + user.name  becomes \"Home group for parth\"",
            "title": "Scripted fields - \"!...\""
        },
        {
            "location": "/actions-streams/actions/#referencing-previous-outcomes",
            "text": "{\n            Type:      \"user_user_id_has_usergroup_usergroup_id\",\n            Method:    \"POST\",\n            Reference: \"user_usergroup\",\n            Attributes: map[string]interface{}{\n                \"user_id\":      \"$user.reference_id\",\n                \"usergroup_id\": \"$usergroup.reference_id\",\n            },\n        },  the  $  sign is to refer the previous outcomes. Here this outcome adds the newly created user to the newly created usergroup.",
            "title": "Referencing previous outcomes"
        },
        {
            "location": "/setting-up/marketplace/",
            "text": "Marketplace\n\n\nDocumentation not ready yet",
            "title": "Market place"
        },
        {
            "location": "/setting-up/marketplace/#marketplace",
            "text": "Documentation not ready yet",
            "title": "Marketplace"
        },
        {
            "location": "/data-modeling/auditing/",
            "text": "Data Audits\n\n\nAll changes in daptin are recorded and history is maintained in audit tables. Audit table are entities just like regular entities. All Patch/Put/Delete calls to daptin will create an entry if the audit table if the entity is changed.\n\n\nAudit tables\n\n\nFor any entity named \nx\n, another tables \nx_audit\n is added by daptin. The audit table will contain all the columns which are present in the original table, plus an extra column \nis_audit_of\n is added, which contains the ID of the original row. The \nis_audit_of\n is a foreign key column to the parent tables \nid\n column.\n\n\nAudit row\n\n\nEach row in the audit table is the copy of the original row just before it is being modified. The audit rows can be accessed just like any other relation.\n\n\nAudit table permissions\n\n\nBy default, everyone has the access to create audit row, and noone has the access to update or delete them. These permissions can be changed, but it is not recommanded at present.\n\n\n\n\n\n\n\n\nType\n\n\nPermission\n\n\n\n\n\n\n\n\n\n\nAudit table permission\n\n\n007007007\n\n\n\n\n\n\nAudit object permission\n\n\n003003003",
            "title": "Data auditing"
        },
        {
            "location": "/data-modeling/auditing/#data-audits",
            "text": "All changes in daptin are recorded and history is maintained in audit tables. Audit table are entities just like regular entities. All Patch/Put/Delete calls to daptin will create an entry if the audit table if the entity is changed.",
            "title": "Data Audits"
        },
        {
            "location": "/data-modeling/auditing/#audit-tables",
            "text": "For any entity named  x , another tables  x_audit  is added by daptin. The audit table will contain all the columns which are present in the original table, plus an extra column  is_audit_of  is added, which contains the ID of the original row. The  is_audit_of  is a foreign key column to the parent tables  id  column.",
            "title": "Audit tables"
        },
        {
            "location": "/data-modeling/auditing/#audit-row",
            "text": "Each row in the audit table is the copy of the original row just before it is being modified. The audit rows can be accessed just like any other relation.",
            "title": "Audit row"
        },
        {
            "location": "/data-modeling/auditing/#audit-table-permissions",
            "text": "By default, everyone has the access to create audit row, and noone has the access to update or delete them. These permissions can be changed, but it is not recommanded at present.     Type  Permission      Audit table permission  007007007    Audit object permission  003003003",
            "title": "Audit table permissions"
        },
        {
            "location": "/data-modeling/data_validation/",
            "text": "Data validation\n\n\nDaptin uses the excellent \ngo-playground/validator\n library to provide extensive validations when creating and updating data.\n\n\nIt gives us the following unique features:\n\n\n\n\nCross Field and Cross Struct validations by using validation tags or custom validators.\n\n\nSlice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.",
            "title": "Data validation"
        },
        {
            "location": "/data-modeling/data_validation/#data-validation",
            "text": "Daptin uses the excellent  go-playground/validator  library to provide extensive validations when creating and updating data.  It gives us the following unique features:   Cross Field and Cross Struct validations by using validation tags or custom validators.  Slice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.",
            "title": "Data validation"
        },
        {
            "location": "/data-modeling/data_conformation/",
            "text": "Data conformations\n\n\nDaptin uses the excellent \nleebenson/conform\n library to apply conformations on data before storing them in the database\n\n\n\n\nConform: keep user input in check (go, golang)\n\n\nTrim, sanitize, and modify struct string fields in place, based on tags.\n\n\n\n\nUse it for names, e-mail addresses, URL slugs, or any other form field where formatting matters.\n\n\nConform doesn't attempt any kind of validation on your fields.",
            "title": "Data conformations"
        },
        {
            "location": "/data-modeling/data_conformation/#data-conformations",
            "text": "Daptin uses the excellent  leebenson/conform  library to apply conformations on data before storing them in the database   Conform: keep user input in check (go, golang)  Trim, sanitize, and modify struct string fields in place, based on tags.   Use it for names, e-mail addresses, URL slugs, or any other form field where formatting matters.  Conform doesn't attempt any kind of validation on your fields.",
            "title": "Data conformations"
        },
        {
            "location": "/data-modeling/state_tracking/",
            "text": "State tracking for entities\n\n\nTracking the status of things is one of the most common operation in most business flows. Daptin has a native support for state tracking and allows a lot of convienent features.\n\n\nState machine\n\n\nA state machine is a description of \"states\" which the object can be in, and list of all valid transitions from one state to another. Let us begin with an example:\n\n\nThe following JSON defines a state machine which has (a hypothetical state machine for tracking todos):\n\n\n\n\nInitial state: to_be_done\n\n\nList of valid states: to_be_done, delayed, started, ongoing, interrupted, completed\n\n\nList of valid transitions, giving name to each event\n\n\n\n\n        \n{\n\n        \n\"Name\"\n:\n \n\"task_status\"\n,\n\n        \n\"Label\"\n:\n \n\"Task Status\"\n,\n\n        \n\"InitialState\"\n:\n \n\"to_be_done\"\n,\n\n        \n\"Events\"\n:\n \n[{\n\n                \n\"Name\"\n:\n \n\"start\"\n,\n\n                \n\"Label\"\n:\n \n\"Start\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"to_be_done\"\n,\n\n                    \n\"delayed\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"started\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"delayed\"\n,\n\n                \n\"Label\"\n:\n \n\"Unable to pick up\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"to_be_done\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"delayed\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"ongoing\"\n,\n\n                \n\"Label\"\n:\n \n\"Record progress\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"started\"\n,\n\n                    \n\"ongoing\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"ongoing\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"interrupted\"\n,\n\n                \n\"Label\"\n:\n \n\"Interrupted\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"started\"\n,\n\n                    \n\"ongoing\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"interrupted\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"resume\"\n,\n\n                \n\"Label\"\n:\n \n\"Resume from interruption\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"interrupted\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"ongoing\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"completed\"\n,\n\n                \n\"Label\"\n:\n \n\"Mark as completed\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"ongoing\"\n,\n\n                    \n\"started\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"completed\"\n\n            \n}\n\n        \n]\n\n    \n}\n\n\n\n\n\nState machines can be uploaded to Daptin just like entities and actions. A JSON/YAML file with a \nStateMachineDescriptions\n top level key can contain an array of state machine descriptions.\n\n\nREST API\n\n\nStart tracking an object by state machine reference id\n\n\nRequest\n\n    POST  /track/start/:stateMachineId\n    {\"typeName\": <entityTypeName>, \"referenceId\": <ReferenceIdOfTheObject> }\n\n\n\nResponse\n\n        \"current_state\": <InitialStateOfTheStateMachine>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>\n        \"permission\": <AuthPermission>\n\n\n\nTrigger an event by name in the state of an object\n\n\n    POST  /track/event/:typename/:ObjectStateInstanceReferenceId/:eventName\n\n\nResponse\n\n        \"current_state\": <NewStateAfterEvent>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>\n\n\n\nEnabling state tracking for entity\n\n\nBegin with marking an entity as trackable. To do this, \n\n\n\n\n\n\ngo to the world tables page and edit the an entity\n\n\n\n\n\n\nCheck the \"Is state tracking enabled\" checkbox\n\n\n\n\n\n\nThis \"is_state_tracking_enabled\" options tells daptin to create the associated state table for the entity. Even though we have not yet specified which state machines are available for this entity.\n\n\nTo make a state machine available for an entity, go to the \"SMD\" tab of this entity on the same page and add the state machine by searching it by name and adding it.\n\n\nIt would not make a lot of sense if the above state machine was allowed for all type of entities.",
            "title": "State tracking"
        },
        {
            "location": "/data-modeling/state_tracking/#state-tracking-for-entities",
            "text": "Tracking the status of things is one of the most common operation in most business flows. Daptin has a native support for state tracking and allows a lot of convienent features.",
            "title": "State tracking for entities"
        },
        {
            "location": "/data-modeling/state_tracking/#state-machine",
            "text": "A state machine is a description of \"states\" which the object can be in, and list of all valid transitions from one state to another. Let us begin with an example:  The following JSON defines a state machine which has (a hypothetical state machine for tracking todos):   Initial state: to_be_done  List of valid states: to_be_done, delayed, started, ongoing, interrupted, completed  List of valid transitions, giving name to each event            { \n         \"Name\" :   \"task_status\" , \n         \"Label\" :   \"Task Status\" , \n         \"InitialState\" :   \"to_be_done\" , \n         \"Events\" :   [{ \n                 \"Name\" :   \"start\" , \n                 \"Label\" :   \"Start\" , \n                 \"Src\" :   [ \n                     \"to_be_done\" , \n                     \"delayed\" \n                 ], \n                 \"Dst\" :   \"started\" \n             }, \n             { \n                 \"Name\" :   \"delayed\" , \n                 \"Label\" :   \"Unable to pick up\" , \n                 \"Src\" :   [ \n                     \"to_be_done\" \n                 ], \n                 \"Dst\" :   \"delayed\" \n             }, \n             { \n                 \"Name\" :   \"ongoing\" , \n                 \"Label\" :   \"Record progress\" , \n                 \"Src\" :   [ \n                     \"started\" , \n                     \"ongoing\" \n                 ], \n                 \"Dst\" :   \"ongoing\" \n             }, \n             { \n                 \"Name\" :   \"interrupted\" , \n                 \"Label\" :   \"Interrupted\" , \n                 \"Src\" :   [ \n                     \"started\" , \n                     \"ongoing\" \n                 ], \n                 \"Dst\" :   \"interrupted\" \n             }, \n             { \n                 \"Name\" :   \"resume\" , \n                 \"Label\" :   \"Resume from interruption\" , \n                 \"Src\" :   [ \n                     \"interrupted\" \n                 ], \n                 \"Dst\" :   \"ongoing\" \n             }, \n             { \n                 \"Name\" :   \"completed\" , \n                 \"Label\" :   \"Mark as completed\" , \n                 \"Src\" :   [ \n                     \"ongoing\" , \n                     \"started\" \n                 ], \n                 \"Dst\" :   \"completed\" \n             } \n         ] \n     }   State machines can be uploaded to Daptin just like entities and actions. A JSON/YAML file with a  StateMachineDescriptions  top level key can contain an array of state machine descriptions.",
            "title": "State machine"
        },
        {
            "location": "/data-modeling/state_tracking/#rest-api",
            "text": "",
            "title": "REST API"
        },
        {
            "location": "/data-modeling/state_tracking/#start-tracking-an-object-by-state-machine-reference-id",
            "text": "Request     POST  /track/start/:stateMachineId\n    {\"typeName\": <entityTypeName>, \"referenceId\": <ReferenceIdOfTheObject> }  Response         \"current_state\": <InitialStateOfTheStateMachine>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>\n        \"permission\": <AuthPermission>",
            "title": "Start tracking an object by state machine reference id"
        },
        {
            "location": "/data-modeling/state_tracking/#trigger-an-event-by-name-in-the-state-of-an-object",
            "text": "POST  /track/event/:typename/:ObjectStateInstanceReferenceId/:eventName \nResponse         \"current_state\": <NewStateAfterEvent>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>",
            "title": "Trigger an event by name in the state of an object"
        },
        {
            "location": "/data-modeling/state_tracking/#enabling-state-tracking-for-entity",
            "text": "Begin with marking an entity as trackable. To do this,     go to the world tables page and edit the an entity    Check the \"Is state tracking enabled\" checkbox    This \"is_state_tracking_enabled\" options tells daptin to create the associated state table for the entity. Even though we have not yet specified which state machines are available for this entity.  To make a state machine available for an entity, go to the \"SMD\" tab of this entity on the same page and add the state machine by searching it by name and adding it.  It would not make a lot of sense if the above state machine was allowed for all type of entities.",
            "title": "Enabling state tracking for entity"
        },
        {
            "location": "/actions-streams/streams/",
            "text": "Streams\n\n\nStreams are complimentary to \nactions\n. Think of streams as views in SQL. A stream is basically one entity + set of transformations and filters on the entity. Streams are read-only and exposed with similar semantics of that of entities. Daptin will expose JSONAPI for each stream just like it does for entities.\n\n\nHere is an example of a stream which exposes list of completed todos only\n\n\n{\n        StreamName:     \"transformed_user\",\n        RootEntityName: \"todo\",\n        Columns: []api2go.ColumnInfo{          // List of columns in this stream\n            {\n                Name:       \"transformed_todo_title\",  \n                ColumnType: \"label\",\n            },\n            {\n                Name:       \"completed_on\",\n                ColumnType: \"datetime\",\n            },\n        },\n        QueryParams: QueryParams{\n            \"Filter\": \"completed=true\",\n            \"Select\": \"title,deadline\",\n        },\n        Transformations: []Transformation{\n            {\n                Operation: \"select\",\n                Attributes: map[string]interface{}{\n                    \"columns\": []string{\"title\", \"deadline\"},\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"title\",\n                    \"newName\": \"transformed_todo_title\",\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"deadline\",\n                    \"newName\": \"completed_on\",\n                },\n            },\n        },\n}   \n\n\n\n\nDaptin uses the library \nkniren/gota\n to systematically specific list of transformations which are applied to the original data stream.",
            "title": "Data streams"
        },
        {
            "location": "/actions-streams/streams/#streams",
            "text": "Streams are complimentary to  actions . Think of streams as views in SQL. A stream is basically one entity + set of transformations and filters on the entity. Streams are read-only and exposed with similar semantics of that of entities. Daptin will expose JSONAPI for each stream just like it does for entities.  Here is an example of a stream which exposes list of completed todos only  {\n        StreamName:     \"transformed_user\",\n        RootEntityName: \"todo\",\n        Columns: []api2go.ColumnInfo{          // List of columns in this stream\n            {\n                Name:       \"transformed_todo_title\",  \n                ColumnType: \"label\",\n            },\n            {\n                Name:       \"completed_on\",\n                ColumnType: \"datetime\",\n            },\n        },\n        QueryParams: QueryParams{\n            \"Filter\": \"completed=true\",\n            \"Select\": \"title,deadline\",\n        },\n        Transformations: []Transformation{\n            {\n                Operation: \"select\",\n                Attributes: map[string]interface{}{\n                    \"columns\": []string{\"title\", \"deadline\"},\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"title\",\n                    \"newName\": \"transformed_todo_title\",\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"deadline\",\n                    \"newName\": \"completed_on\",\n                },\n            },\n        },\n}     Daptin uses the library  kniren/gota  to systematically specific list of transformations which are applied to the original data stream.",
            "title": "Streams"
        },
        {
            "location": "/auth/permissions/",
            "text": "Permission model\n\n\nThe \nworld\n table contains two columns:\n\n\n\n\nPermission\n: defines the entity level permission\n\n\nDefault permission\n: defines the default permission for a new object of this entity type\n\n\n\n\nThe default permission for an object is picked from the default permission setting, and can be changed after the object creation (if the permission allows so).",
            "title": "Permission model"
        },
        {
            "location": "/auth/permissions/#permission-model",
            "text": "The  world  table contains two columns:   Permission : defines the entity level permission  Default permission : defines the default permission for a new object of this entity type   The default permission for an object is picked from the default permission setting, and can be changed after the object creation (if the permission allows so).",
            "title": "Permission model"
        },
        {
            "location": "/extend/oauth_connection/",
            "text": "OAuth Connections\n\n\nDaptin is natively aware of oauth2 flows and can seamlessly handle oauth tokens and refresh tokens (if provided).\n\n\nOauth connection are useful in consuming other parts of daptin easily, like cloud storage, sub-sites, 3rd party logins.\n\n\nTo begin using oauth involved flows (eg GoogleDrive as data storage) first daptin needs to be configured about the oauth connection parameters. \n\n\nCreating a new oauth connection\n\n\n\n\nLog into the dashboard\n\n\nClick the tile \"OAuth connections\"\n\n\nClick the green \"+\" button on the top right\n\n\nLeave \"Allow Login\" unchecked. We can change this later\n\n\nEnter your service's auth endpoint, eg for google its \"https://accounts.google.com/o/oauth2/auth\"\n\n\nClient Id\n: Client Id generated by the service for daptin\n\n\nClient Secret\n: Client secret, this will be stored after encryption and wont be retrievable from daptin.\n\n\nName\n: Identify it with a name \n\n\nRedirect Uri\n: Change this to \nhttp://<Domain>/oauth/response\n instead of \n/oauth/response\n\n\nResponse Type\n: code\n\n\nScope\n: Appropriate score defined by the oauth service to access the resource\n\n\nEg: \n\n\nfor gdrive: \nhttps://www.googleapis.com/auth/drive\n\n\nfor gsheet: \nhttps://www.googleapis.com/auth/spreadsheets\n\n\n\n\n\n\nToken Url\n: The token info url of the oauth service: eg: \nhttps://accounts.google.com/o/oauth2/token\n\n\n\n\nNow you can \ngenerate a token",
            "title": "OAuth connections"
        },
        {
            "location": "/extend/oauth_connection/#oauth-connections",
            "text": "Daptin is natively aware of oauth2 flows and can seamlessly handle oauth tokens and refresh tokens (if provided).  Oauth connection are useful in consuming other parts of daptin easily, like cloud storage, sub-sites, 3rd party logins.  To begin using oauth involved flows (eg GoogleDrive as data storage) first daptin needs to be configured about the oauth connection parameters.",
            "title": "OAuth Connections"
        },
        {
            "location": "/extend/oauth_connection/#creating-a-new-oauth-connection",
            "text": "Log into the dashboard  Click the tile \"OAuth connections\"  Click the green \"+\" button on the top right  Leave \"Allow Login\" unchecked. We can change this later  Enter your service's auth endpoint, eg for google its \"https://accounts.google.com/o/oauth2/auth\"  Client Id : Client Id generated by the service for daptin  Client Secret : Client secret, this will be stored after encryption and wont be retrievable from daptin.  Name : Identify it with a name   Redirect Uri : Change this to  http://<Domain>/oauth/response  instead of  /oauth/response  Response Type : code  Scope : Appropriate score defined by the oauth service to access the resource  Eg:   for gdrive:  https://www.googleapis.com/auth/drive  for gsheet:  https://www.googleapis.com/auth/spreadsheets    Token Url : The token info url of the oauth service: eg:  https://accounts.google.com/o/oauth2/token   Now you can  generate a token",
            "title": "Creating a new oauth connection"
        },
        {
            "location": "/extend/oauth_token/",
            "text": "Oauth Token\n\n\nOauth tokens can be used internally to connect to other services which require authentication.\n\n\n\n\nTokens and Refresh token are stored with encryption in the database\n\n\nRefresh token is used to generate new tokens if the existing token expires\n\n\n\n\nGenerate a new token\n\n\n\n\nClick the \"expand\" icon on the card to go into detailed view\n\n\nOn the right side, under the \"Actions\" find \"Authenticate via OAuth\"\n\n\nClick it and click \"Submit\" in the next form to initiate the flow",
            "title": "OAuth tokens"
        },
        {
            "location": "/extend/oauth_token/#oauth-token",
            "text": "Oauth tokens can be used internally to connect to other services which require authentication.   Tokens and Refresh token are stored with encryption in the database  Refresh token is used to generate new tokens if the existing token expires",
            "title": "Oauth Token"
        },
        {
            "location": "/extend/oauth_token/#generate-a-new-token",
            "text": "Click the \"expand\" icon on the card to go into detailed view  On the right side, under the \"Actions\" find \"Authenticate via OAuth\"  Click it and click \"Submit\" in the next form to initiate the flow",
            "title": "Generate a new token"
        }
    ]
}